import election;
import topic;
import user;
import user.meta;
import util;

operation remove_topic(username: text, descriptor_id: byte_array, topic_id: text) {
    val user = user.get_verified_user(username, descriptor_id);

    val recentElection = election.representative_election@{ .completed == true } ( .id, @sort_desc .timestamp ) limit 1;
    val representative = representative @{ user, .representative_election.id == recentElection.id };

    val topic = topic.topic @{ .id == topic_id };
    update topic ( title = "[Removed]", message = "Removed by @" + user.name, removed = true );

    create representative_action(
        id = op_context.transaction.tx_rid,
        representative,
        op_context.last_block_time,
        action = "Topic /t/" + topic.id + " was removed by @" + user.name
    );
}

operation remove_topic_reply(username: text, descriptor_id: byte_array, topic_reply_id: text) {
    val user = user.get_verified_user(username, descriptor_id);

    val recentElection = election.representative_election@{ .completed == true } ( .id, @sort_desc .timestamp ) limit 1;
    val representative = representative @{ user, .representative_election.id == recentElection.id };

    val reply = topic.topic_reply @{ .id == topic_reply_id };
    update reply ( message = "Removed by @" + user.name, removed = true );

    create representative_action(
        id = op_context.transaction.tx_rid,
        representative,
        op_context.last_block_time,
        action = "Reply in topic /t/" + reply.topic.id + " was removed by @" + user.name
    );
}

operation suspend_user(username: text, descriptor_id: byte_array, user_to_be_suspended: text) {
    val user = user.get_verified_user(username, descriptor_id);

    val recentElection = election.representative_election@{ .completed == true } ( .id, @sort_desc .timestamp ) limit 1;
    val representative = representative @{ user, .representative_election.id == recentElection.id };

    val suspendee = user.user@{ .name == user_to_be_suspended };
    val suspendee_meta = meta.user_meta@{ suspendee };

    require(
    	suspendee_meta.suspended_until < op_context.last_block_time,
    	util.app_error(util.error_type.REPRESENTATIVE_ALREADY_SUSPENDED, "Suspend user")
    );

    val updatedTimesSuspended = suspendee_meta.times_suspended + 1;
    val oneDayMillis = 86400000;
    val daysSuspended = updatedTimesSuspended * updatedTimesSuspended;
    val suspensionTimeMillis = daysSuspended * oneDayMillis;

    update suspendee_meta (
        suspended_until = op_context.last_block_time + suspensionTimeMillis,
        times_suspended = updatedTimesSuspended
    );

    var daysString = " days ";
    if (daysSuspended == 1) {
        daysString = " day ";
    }

    create representative_action(
        id = op_context.transaction.tx_rid,
        representative,
        op_context.last_block_time,
        action = "@" + suspendee.display_name + " was suspended for " + daysSuspended + daysString +  "by @" + user.display_name
    );
}

operation distrust_representative(descriptor_id: byte_array, distruster: name, distrusted: name) {
	require(distruster != distrusted, "You can't distrust yourself");
	
	val user = user.get_verified_user(distruster, descriptor_id);
	val distruster_rep = representative@{ user };
	val distrusted_rep = representative@{ user.name == distrusted };

    val recent_election = election.representative_election@{ .completed == true } ( .id, @sort_desc .timestamp ) limit 1;
    val representative = representative @{ user, .representative_election.id == recent_election.id };
    
    create representative_distrust(distruster = distruster_rep, distrusted = distrusted_rep);
    
    val nr_of_representatives = representative@*{ 
    	.representative_election.id == recent_election.id
    } ( .user ).size();
    
    val nr_of_distrusts = representative_distrust@*{ 
    	.distrusted == distrusted_rep
    }( .distruster ).size();
    
    val required_distrusts = integer((nr_of_representatives * 0.5).ceil());
    
    log("Required distrusts left: ", required_distrusts);
    if (nr_of_distrusts > 1 and nr_of_distrusts >= required_distrusts) {
    	delete distrusted_rep;
    }
}

