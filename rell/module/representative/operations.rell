operation remove_topic(username: text, topic_id: text) {
    val user = user@{ .name == username};
    require(is_signer(user.pubkey));

    val recentElection = representative_election@{ .completed == true } ( .id, sort .timestamp );
    val representative = representative @{ user, .representative_election.id == recentElection.id };

    val topic = topic @{ .id == topic_id };
    update topic ( title = "[Removed]", message = "Removed by @" + user.name, removed = true );
    delete topic_tag @* { topic @{ .id == topic_id }};
    create representative_action(
        id = op_context.transaction.tx_rid, 
        representative,
        op_context.last_block_time,
        action = "Topic /t/" + topic.id + " was removed by @" + user.name
    );
}

operation remove_topic_reply(username: text, topic_reply_id: text) {
    val user = user@{ .name == username};
    require(is_signer(user.pubkey));

    val recentElection = representative_election@{ .completed == true } ( .id, sort .timestamp );
    val representative = representative @{ user, .representative_election.id == recentElection.id };

    val reply = topic_reply @{ .id == topic_reply_id };
    update reply ( message = "Removed by @" + user.name, removed = true );
    
    val replyToTopicTags = reply_to_topic_tag @* { topic_reply_id };
    for (replyToTopicTag in replyToTopicTags) {
        delete replyToTopicTag;
        delete topic_tag @? { replyToTopicTag.topic_tag.id };
    }

    create representative_action(
        id = op_context.transaction.tx_rid, 
        representative,
        op_context.last_block_time,
        action = "Reply in topic /t/" + reply.topic.id + " was removed by @" + user.name
    );
}

operation suspend_user(username: text, user_to_be_suspended: text) {
    val user = user@{ .name == username};
    require(is_signer(user.pubkey));

    val recentElection = representative_election@{ .completed == true } ( .id, sort .timestamp );
    val representative = representative @{ user, .representative_election.id == recentElection.id };

    val suspendee_meta = user_meta@{ user@{ user_to_be_suspended }};

    require(suspendee_meta.suspended_until < op_context.last_block_time);

    val updatedTimesSuspended = suspendee_meta.times_suspended + 1;
    val oneDayMillis = 86400000;
    val daysSuspended = updatedTimesSuspended * updatedTimesSuspended;
    val suspensionTimeMillis = daysSuspended * oneDayMillis;

    update suspendee_meta ( 
        suspended_until = op_context.last_block_time + suspensionTimeMillis, 
        times_suspended = updatedTimesSuspended
    );

    var daysString = " days ";
    if (daysSuspended == 1) {
        daysString = " day ";
    }

    create representative_action(
        id = op_context.transaction.tx_rid, 
        representative,
        op_context.last_block_time,
        action = "@" + user_to_be_suspended + " was suspended for " + daysSuspended + daysString +  "by @" + user.name
    );
}

operation tmp_add_representative(admin_name: name, name) {
    require(is_signer(admin@{ .user.name == admin_name }( .user.pubkey )));
    val currentElection = representative_election @ { .timestamp <= op_context.last_block_time, .completed == true } (
        .id,
        -sort .timestamp
    ) limit 1;

    create representative(user@{ .name == name }, representative_election@{ .id == currentElection.id });
}

operation tmp_remove_representative(admin_name: name, name) {
    require(is_signer(admin@{ .user.name == admin_name }( .user.pubkey )));
    val currentElection = representative_election @ { .timestamp <= op_context.last_block_time, .completed == true } (
        .id,
        -sort .timestamp
    ) limit 1;

    delete representative @?{ user@{ .name == name }, representative_election@{ .id == currentElection.id }};
}