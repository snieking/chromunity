<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<dict>
    <entry key="blockstrategy">
        <dict>
            <entry key="blockdelay">
                <int>750</int>
            </entry>
            <entry key="maxblocktime">
                <int>15000</int>
            </entry>
            <entry key="maxblocktransactions">
                <int>500</int>
            </entry>
            <entry key="name">
                <string>net.postchain.base.BaseBlockBuildingStrategy</string>
            </entry>
        </dict>
    </entry>
    <entry key="configurationfactory">
        <string>net.postchain.gtx.GTXBlockchainConfigurationFactory</string>
    </entry>
    <entry key="gtx">
        <dict>
            <entry key="modules">
                <array>
                    <string>net.postchain.rell.module.RellPostchainModuleFactory</string>
                    <string>net.postchain.gtx.StandardOpsGTXModule</string>
                </array>
            </entry>
            <entry key="rell">
                <dict>
                    <entry key="mainFile">
                        <string>main.rell</string>
                    </entry>
                    <entry key="sources_v0.9">
                        <dict>
                            <entry key="channel/index.rell">
                                <string>class channel {
    key name, topic;
    index timestamp;
    display_name: name;
}

class channel_following {
    key user, name;
}

include 'operations';
include 'queries';</string>
                            </entry>
                            <entry key="channel/operations.rell">
                                <string>operation follow_channel(username: text, descriptor_id: byte_array, name) {
    val user = get_verified_user(username, descriptor_id);
    create channel_following(user, name.lower_case());
}

operation unfollow_channel(username: text, descriptor_id: byte_array, name) {
    val user = get_verified_user(username, descriptor_id);
    delete channel_following@{ user, name.lower_case()};
}</string>
                            </entry>
                            <entry key="channel/queries.rell">
                                <string>query get_topics_by_channel_prior_to_timestamp(name, timestamp, page_size: integer) {
    // TODO: .lower_case() in Rell 0.9
    return channel@*{
        .name == name,
        .topic.last_modified &lt; timestamp,
        .topic.removed == false
    } (
        id=.topic.id,
        author=.topic.author.display_name,
        title=.topic.title,
        message=.topic.message,
        timestamp=.topic.timestamp,
        -sort last_modified=.topic.last_modified,
        removed=.topic.removed
    ) limit page_size;
}

query get_topics_by_channel_after_timestamp(name, timestamp) {
    return channel@*{ 
        .name == name,
        .topic.last_modified &gt; timestamp,
        .topic.removed == false
    } (
        id=.topic.id,
        author=.topic.author.display_name,
        title=.topic.title,
        message=.topic.message,
        timestamp=.topic.timestamp,
        -sort last_modified=.topic.last_modified,
        removed=.topic.removed
    );
}

query count_topics_by_channel(name) {
    return channel@*{ .name == name } ( .name ).size();
}

query count_channel_followers(name) {
    return channel_following@*{ .name == name } ( .user.name ).size();
}

query get_topics_by_followed_channels_prior_to_timestamp(username: text, timestamp, page_size: integer) {
    val user = user@{ .name == username};
    return (channel, channel_following) @* {
        channel_following.user == user,
        channel_following.name == channel.name,
        channel.topic.last_modified &lt; timestamp,
        channel.topic.removed == false
    }
    (
        id=channel.topic.id,
        author=channel.topic.author.display_name,
        title=channel.topic.title,
        message=channel.topic.message,
        timestamp=channel.topic.timestamp,
        -sort last_modified=channel.topic.last_modified,
        removed=channel.topic.removed
    ) limit page_size;
}

query get_topics_by_followed_channels_after_timestamp(username: text, timestamp, page_size: integer) {
    val user = user@{ .name == username};
    return (channel, channel_following) @* {
        channel_following.user == user,
        channel_following.name == channel.name,
        channel.topic.last_modified &gt; timestamp,
        channel.topic.removed == false
    }
    (
        id=channel.topic.id,
        author=channel.topic.author.display_name,
        title=channel.topic.title,
        message=channel.topic.message,
        timestamp=channel.topic.timestamp,
        -sort last_modified=channel.topic.last_modified,
        removed=channel.topic.removed
    ) limit page_size;
}

query get_followed_channels(username: text) {
    val user = user@{ .name == username};
    return channel_following@*{ user } ( .name );
}

query get_all_channels() {
    return channel@*{} ( .display_name );
}

query get_channels_since(timestamp) {
    return channel@*{ .timestamp &gt; timestamp }( .display_name );
}

query get_topic_channels_belongings(topic_id: text) {
    return channel@*{ topic@{ .id == topic_id }} ( .display_name );
}
</string>
                            </entry>
                            <entry key="chat/index.rell">
                                <string>class chat {
	key id: text;
	mutable title: text;
	timestamp;
}

class chat_user {
	key user;
	rsa_pubkey: text;
}

class chat_membership {
	key chat, member: chat_user;
	encrypted_chat_key: text;
}

class chat_message {
	index chat;
	index sender: chat_user;
	index timestamp;
	encrypted_msg: text;
}

record chat_record {
	id: text;
	title: text;
	last_message: message_record?;
	encrypted_chat_key: text;
	timestamp;
}

record message_record {
	sender: name;
	timestamp;
	encrypted_msg: text;
}

include 'operations';
include 'queries';</string>
                            </entry>
                            <entry key="chat/operations.rell">
                                <string>operation create_chat(chat_id: text, descriptor_id: byte_array, username: text, title: text, encrypted_chat_key: text) {
	val founder = get_verified_user(username, descriptor_id);
	
	val chat = create chat(id = chat_id, title = title, timestamp = op_context.last_block_time);
	create chat_membership(chat, chat_user@{ .user == founder }, encrypted_chat_key);
}

operation create_chat_user(descriptor_id: byte_array, username: text, rsa_pubkey: text) {
	val user = get_verified_user(username, descriptor_id);
	create chat_user(user, rsa_pubkey);
}

operation add_user_to_chat(descriptor_id: byte_array, username: text, chat_id: text, target_user: text, encrypted_chat_key: text) {
	val user_already_in_chat = get_verified_user(username, descriptor_id);
	val chat = chat@{ .id == chat_id };
	create chat_membership(chat, chat_user@{ .user.name == target_user.lower_case() }, encrypted_chat_key);
}

operation leave_chat(descriptor_id: byte_array, username: text, chat_id: text) {
	val user = get_verified_user(username, descriptor_id);
	val chat = chat@{ .id == chat_id };

	delete chat_membership@{ chat, chat_user@{ user }};
	
	if (chat_membership@*{ chat } ( .member ).size() == 0) {
		delete chat_message@*{ chat };
		delete chat;
	}
}

operation modify_chat_title(descriptor_id: byte_array, username: text, chat_id: text, title: text) {
	val user = get_verified_user(username, descriptor_id);
	val chat = chat@{ .id == chat_id };
	chat_membership@{ chat, chat_user@{ user }};
	update chat ( title = title );
}

operation send_chat_message(chat_id: text, descriptor_id: byte_array, username: name, encrypted_msg: text) {
	val user = get_verified_user(username, descriptor_id);
	
	val chat = chat@{ .id == chat_id };
	val chat_user = chat_user@{ user };
	val chat_member = chat_membership@?{ chat, chat_user };
	require(chat_member != null, app_error(error_type.USER_UNAUTHORIZED, "Only a chat member can send a message"));
	
	create chat_message(chat, chat_user, op_context.last_block_time, encrypted_msg);
}</string>
                            </entry>
                            <entry key="chat/queries.rell">
                                <string>query get_chat_user_pubkey(username: name): text? {
	return chat_user@?{ .user.name == username.lower_case() } ( .rsa_pubkey );
}

query get_user_chats(username: name): list&lt;chat_record&gt; {
	
	val member_chats = chat_membership@*{ .member.user.name == username.lower_case() };
	val chat_records = list&lt;chat_record&gt;();
	
	for (member_chat in member_chats) {
		val latest_message = chat_message@?{ .chat == member_chat.chat } ( .sender, -sort .timestamp, .encrypted_msg, -sort .chat.timestamp ) limit 1;
		
		if (latest_message != null) {
			val message = message_record(sender = latest_message!!.sender.user.display_name, timestamp = latest_message!!.timestamp, encrypted_msg = latest_message!!.encrypted_msg);
			chat_records.add(chat_record(id = member_chat.chat.id, title = member_chat.chat.title, last_message = message, encrypted_chat_key = member_chat.encrypted_chat_key, timestamp = member_chat.chat.timestamp));		
		} else {
			chat_records.add(chat_record(id = member_chat.chat.id, title = member_chat.chat.title, last_message = null, encrypted_chat_key = member_chat.encrypted_chat_key, timestamp = member_chat.chat.timestamp));	
		}
		
	}
	
	return chat_records;
}

query get_chat_messages(id: text) {
	return chat_message@*{ .chat.id == id } ( sender = chat_message.sender.user.display_name,  sort timestamp = chat_message.timestamp, encrypted_msg = chat_message.encrypted_msg );
}

query get_chat_participants(id: text) {
	return chat_membership@*{ .chat.id == id } ( .member.user.display_name );
}</string>
                            </entry>
                            <entry key="election/index.rell">
                                <string>class representative_election {
    key id: text;
    index timestamp;
    mutable completed: boolean;
    index completed;
}

class representative_election_candidate {
  key representative_election, user;
}

class representative_election_vote {
    key user, representative_election_candidate;
}

include 'operations';
include 'queries';</string>
                            </entry>
                            <entry key="election/operations.rell">
                                <string>operation trigger_election(admin_user: text, descriptor_id: byte_array, id: text, timestamp) {
    val user = get_verified_user(admin_user, descriptor_id);
    assert_admin(user);

    val currentElection = representative_election @? { .completed == false };

    if (currentElection == null) {
        create representative_election(id, timestamp, false);
    }
}
  
operation complete_election(admin_user: text, descriptor_id: byte_array, representatives: set&lt;text&gt;) {
    val op_user = get_verified_user(admin_user, descriptor_id);
    assert_admin(op_user);

    val currentElection = representative_election @ { .completed == false };
    update currentElection ( completed = true );

    for (representative in representatives) {
        val user = user@{ .name == representative };
        create representative(user, currentElection);
    }
}

operation vote_for_candidate(voter: name, descriptor_id: byte_array, candidate: name) {
    val user = get_verified_user(voter, descriptor_id);

    val currentElection = representative_election @ { .completed == false };
    create representative_election_vote(
        user,
        representative_election_candidate@{ user@{ .name == candidate }, currentElection }
    );
}

operation update_vote_for_candidate(voter: name, descriptor_id: byte_array, candidate: name) {
    val user = get_verified_user(voter, descriptor_id);

    val currentElection = representative_election @ { .completed == false };    
    val election_candidate = representative_election_candidate@{
        currentElection,
        user@{ .name == candidate }
    };

    delete representative_election_vote@?{
        .user == user,
        election_candidate
    };

    create representative_election_vote(
        user,
        representative_election_candidate@{
            .user.name == candidate,
            currentElection
        }
    );
}

operation sign_up_for_election(name, descriptor_id: byte_array) {
    val user = get_verified_user(name, descriptor_id);

    val currentElection = representative_election @ { .completed == false };

    create representative_election_candidate(currentElection, user);
}</string>
                            </entry>
                            <entry key="election/queries.rell">
                                <string>query get_election_votes() {
    return representative_election_vote@*{
        representative_election_candidate@{ 
            representative_election @ { .completed == false }
        }
    } ( .representative_election_candidate.user.name );
}

query get_election_candidates() {
    return representative_election_candidate@*{
        representative_election @ { .completed == false }
    } ( .user.name );
}

query get_next_election(timestamp) {
    return representative_election@?{ .timestamp &gt; timestamp } ( .id, -sort .timestamp ) limit 1;
}

query get_uncompleted_election() {
    return representative_election@?{
        .completed == false
    } ( .id );
}

query get_user_vote_in_election(name) {
    return representative_election_vote@?{
        .user == user@{ .name == name },
        .representative_election_candidate.representative_election == representative_election @ { .completed == false }
    } ( .representative_election_candidate.user.name );
}

query get_current_representative_period(timestamp) {
    return representative_election @? { .timestamp &lt;= timestamp, .completed == true } ( .id, -sort .timestamp ) limit 1;
}</string>
                            </entry>
                            <entry key="follow/index.rell">
                                <string>class follow {
    key follower: user, follows: user;
}

include 'operations';
include 'queries';</string>
                            </entry>
                            <entry key="follow/operations.rell">
                                <string>operation create_following(follower: text, descriptor_id: byte_array, follows: text) {
    require(follower != follows, app_error(error_type.ILLEGAL_ACTION, "Follow another user"));
    val user = get_verified_user(follower, descriptor_id);
    create follow(follower = user, follows = user@{ .name == follows.lower_case() });
}

operation remove_following(follower: text, descriptor_id: byte_array, follows: text) {
    require(follower != follows);
    val user = get_verified_user(follower, descriptor_id);

    delete follow@{ .follower == user, .follows == user@{ .name == follows.lower_case() } };
}
</string>
                            </entry>
                            <entry key="follow/queries.rell">
                                <string>
query get_user_followers(name) {
    return follow@*{ .follows == user @ { .name == name } }( .follower.name );
}

query get_user_follows(name) {
    return follow@*{ .follower == user@{ .name == name } } ( .follows.name );
}
</string>
                            </entry>
                            <entry key="ft3_config.rell">
                                <string>object ft3_config {
  blockchain_name: text = "Chromunity";
  blockchain_website: text = "chromunity.com";
  blockchain_description: text = "Decentralized Reddit";
}
</string>
                            </entry>
                            <entry key="lib/ft3/account/auth_basic.rell">
                                <string>//namespace ft3 {

// Auth type:

// "S" - single-sig
// "M" - multi-sig

record single_sig_args {
       flags: set&lt;text&gt;;
       pubkey;
}

record multi_sig_args {
       flags: set&lt;text&gt;;
       signatures_required: integer;
       pubkeys: list&lt;pubkey&gt;;
}

function check_single_sig_auth(args: byte_array, participants: list&lt;byte_array&gt;, required_flags: list&lt;text&gt;): boolean {
    require(participants.size() == 1);
    val ss_args = single_sig_args.from_bytes(args);
    return
          ss_args.flags.contains_all(required_flags)
            and 
          is_signer(participants[0]);
}

function check_multi_sig_auth(args: byte_array, participants: list&lt;byte_array&gt;, required_flags: list&lt;text&gt;): boolean {
   val multi_sign_args = multi_sig_args.from_bytes(args);
   if (not (multi_sign_args.flags.contains_all(required_flags))) return false;
   var num_sign = multi_sign_args.signatures_required;
   for(s in participants) {
      if(is_signer(s)) {
          num_sign -= 1;
          if(num_sign &lt; 1) {return true;}
      }
   }
   return false;
}

function check_auth_args (a_t: text, args: byte_array, participants: list&lt;byte_array&gt;, required_flags: list&lt;text&gt;): boolean {
    return when (a_t) {
        "S" -&gt; check_single_sig_auth(args, participants, required_flags);
        "M" -&gt; check_multi_sig_auth(args, participants, required_flags);
        else -&gt; false;
    };
}


function require_auth (account, descriptor_id: byte_array, required_flags: list&lt;text&gt;) {
   val account_auth_descriptor = account_auth_descriptor @ {
     account,
     .descriptor_id == descriptor_id
   };
   require(
      check_auth_args(
       account_auth_descriptor.auth_type,
       account_auth_descriptor.args,
       auth_descriptor_participant @* { account_auth_descriptor } ( .id ),
       required_flags
       )
   );  
}


//}</string>
                            </entry>
                            <entry key="lib/ft3/account/main.rell">
                                <string>// namespace ft3 {

record auth_descriptor {
    auth_type: text;
    participants: list&lt;byte_array&gt;;
    args: list&lt;gtv&gt;;
}

class account {
    key id: byte_array;      
}

class account_meta {
    meta_key: text;
    value: byte_array;
    index account, meta_key;
    index meta_key, value;
}

class account_auth_descriptor {
     descriptor_id: byte_array;
     key account, descriptor_id;
     index descriptor_id;
     auth_type: text;
     args: byte_array;
}

class auth_descriptor_participant {
    key account_auth_descriptor, id: byte_array;
}

function _add_auth_descriptor (account, auth_descriptor) {
     val descriptor_id = auth_descriptor.hash();
     val account_auth_descriptor = create account_auth_descriptor (
        account, descriptor_id,
        auth_descriptor.auth_type,
        args = auth_descriptor.args.to_gtv().to_bytes()
     );
     for (participant in auth_descriptor.participants) {
        create auth_descriptor_participant(account_auth_descriptor, id = participant);
     }
}

function create_account_with_auth (auth_descriptor): byte_array {
    print(auth_descriptor);
     val id = auth_descriptor.hash();
     val acc = create account (id);
     _add_auth_descriptor(
        acc, auth_descriptor
     );
     return id;
}

operation delete_auth_descriptor (account_id: byte_array, auth_descriptor_id: byte_array, delete_descriptor_id: byte_array) {
      val account = account @ { .id == account_id };
      require_auth(account, auth_descriptor_id, ["A"]);
      delete account_auth_descriptor @ {
         .account == account,
         .descriptor_id == delete_descriptor_id
      };
}

operation delete_all_auth_descriptors_exclude(account_id: byte_array, auth_descriptor_id: byte_array) {
    val account = account @ { .id == account_id };
    require_auth(account, auth_descriptor_id, ["A"]);

    delete (adp: auth_descriptor_participant, ad: account_auth_descriptor) @* {
        ad.account == account and ad.descriptor_id != auth_descriptor_id and adp.account_auth_descriptor == ad
    };

    delete account_auth_descriptor @* {
       .account == account,
       .descriptor_id != auth_descriptor_id
    };
}

operation add_auth_descriptor (account_id: byte_array, auth_id: byte_array, new_desc: auth_descriptor) {
      val account = account @ { .id == account_id };
      require_auth(account, auth_id, ["A"]);
      _add_auth_descriptor(account, new_desc);
}

query get_account_auth_descriptors(id: byte_array) {
    return account_auth_descriptor @* {
        .account.id == id
    } (
        id = .descriptor_id,
        type = .auth_type,
        args = .args
    );
}

query get_account_by_id(id: byte_array) {
    return account @? { id } ( .id );
}

query get_account_by_auth_descriptor(auth_descriptor) {
    return account @? { .id == auth_descriptor.hash() } ( .id );
}

query get_accounts_by_participant_id(id: byte_array) {
    return auth_descriptor_participant @* { id } ( .account_auth_descriptor.account.id );
}

query get_accounts_by_auth_descriptor_id(descriptor_id: byte_array) {
    return account_auth_descriptor @* { descriptor_id } ( .account.id );
}</string>
                            </entry>
                            <entry key="lib/ft3/asset.rell">
                                <string>//namespace ft3 {
  class asset {
    id: byte_array;
    key id;
    key name;
    issuing_chain_rid: byte_array;
  }

  class balance {
    key account, asset;
    mutable amount: integer = 0;
  }

  function ensure_balance(account, asset): balance {
    val balance = balance @? {asset, account};
    if (balance != null) {
       return balance;
    }
    else return create balance(account, asset, amount = 0);
  }

  function register_asset (name, issuing_chain_rid: byte_array): asset {
   val id = (name, issuing_chain_rid).hash();
   return create asset (id, name, issuing_chain_rid);
  }

  query get_asset_balances(account_id: byte_array) {
    return balance @* { .account.id == account_id } (
        id = .asset.id,
        name = .asset.name,
        amount = .amount,
        chain_id = .asset.issuing_chain_rid
    );
  }

  query get_asset_balance(account_id: byte_array, asset_id: byte_array) {
    return balance @? {
        .account.id == account_id,
        .asset.id == asset_id
    } (
        id = .asset.id,
        name = .asset.name,
        amount = .amount,
        chain_id = .asset.issuing_chain_rid
    );
  }

  query get_asset_by_name(name) {
    return asset @* { name } (
        .id,
        .name,
        .issuing_chain_rid
    );
  }
// }

</string>
                            </entry>
                            <entry key="lib/ft3/blockchain.rell">
                                <string>object blockchain {
    mutable name: text = ft3_config.blockchain_name;
    mutable website: text = ft3_config.blockchain_website;
    mutable description: text = ft3_config.blockchain_description;
}

class linked_chain {
    key chain_rid: byte_array;
}

operation update_blockchain(name, website: text, description: text) {
    blockchain.name = name;
    blockchain.website = website;
    blockchain.description = description;
}

query get_blockchain_info() {
    return (
        name = blockchain.name,
        website = blockchain.website,
        description = blockchain.description
    );
}

operation link_chain(chain_rid: byte_array) {
    create linked_chain(chain_rid);
}

query get_linked_chains() {
    return linked_chain @* {} ( .chain_rid );
}

query is_linked_with_chain(chain_rid: byte_array) {
    return linked_chain @? { chain_rid } != null;
}</string>
                            </entry>
                            <entry key="lib/ft3/core.rell">
                                <string>include "account/main";
include "account/auth_basic";
include "asset";
include "history";
include "transfer";</string>
                            </entry>
                            <entry key="lib/ft3/crosschain/blockchain.rell">
                                <string>class asset_origin {
    key asset;
    origin_chain_rid: byte_array;
}

function blockchain_account_id (blockchain_rid: byte_array): byte_array {
   return ("B", blockchain_rid).hash();
}

function ensure_blockchain_account (blockchain_rid: byte_array): account {
   val blockchain_account_id = blockchain_account_id(blockchain_rid);
   val acc = account @? { .id == blockchain_account_id };
   return if (acc??)  acc
   else create account (id = blockchain_account_id);
}

function get_blockchain_account (blockchain_rid: byte_array): account {
   return account @ { .id == blockchain_account_id(blockchain_rid) };
}

</string>
                            </entry>
                            <entry key="lib/ft3/crosschain/dev.rell">
                                <string>operation dev_register_xc_asset (name, issuing_chain_rid: byte_array, origin_chain_rid: byte_array) {
    require_dev();
    val asset = register_asset(name, issuing_chain_rid);
    create asset_origin (asset, origin_chain_rid);
}</string>
                            </entry>
                            <entry key="lib/ft3/crosschain/structures.rell">
                                <string>record operation_rec {
   name;
   args: list&lt;gtv&gt;;
}

record transaction_body_rec {
    blockchain_rid: byte_array;
    operations: list&lt;operation_rec&gt;;
    signers: list&lt;gtv&gt;;
}

record transaction_rec {
   body: transaction_body_rec;
   signatures: list&lt;gtv&gt;;
}

record transaction_proof {
     tx: virtual&lt;transaction_rec&gt;;
     // block_header: byte_array;
     // merkle_path: virtual&lt;list&lt;byte_array&gt;&gt;;
     // tx_index: integer;
     block_rid: byte_array;
     block_signers: list&lt;byte_array&gt;;
     signatures: list&lt;byte_array&gt;;     
}

function verify_transaction_proof( p: transaction_proof ) {
   // TODO
}</string>
                            </entry>
                            <entry key="lib/ft3/crosschain/transfer.rell">
                                <string>record xc_target {
    account_id: byte_array;
    extra: map&lt;text, gtv&gt;;
}

function add_to_blockchain_balance (blockchain_rid: byte_array, asset, amount: integer) {
    require( chain_context.blockchain_rid != blockchain_rid ); // cannot add to own account

    val origin_chain_rid = asset_origin @? { asset } .origin_chain_rid;

    if (exists(origin_chain_rid) and (blockchain_rid == origin_chain_rid)) {
       // do nothing. in future we might track origin
    } else {
         val bc_acc = ensure_blockchain_account(blockchain_rid);
         ensure_balance(bc_acc, asset).amount += amount;
    }
}

operation init_xfer (source: xfer_input, target: xc_target, hops: list&lt;byte_array&gt;) {
     consume_input(source, 0, map&lt;asset, integer&gt;());
     val asset = asset @ { .id == source.asset_id };
     add_to_blockchain_balance( hops[0], asset, source.amount );
}

record init_xfer_args {
          source: xfer_input;
          target: xc_target;
          hops: list&lt;byte_array&gt;;
}

class applied_transfers { key tx_rid: byte_array; }

operation apply_xfer (
       init_tx_rid: byte_array,
       init_tx: transaction_proof,
       prev_hop: transaction_proof?,
       hop_index: integer
) {
      require(init_tx.tx.hash() == init_tx_rid);
      verify_transaction_proof( init_tx );
      create applied_transfers (init_tx_rid);

      require(init_tx.tx.body.operations[0].name == "ft3.xc.init_xfer");
      val init_args = init_xfer_args.from_gtv(
         init_tx.tx.body.operations[0].args.to_full().to_gtv()
      );
      val my_blockchain_rid = chain_context.blockchain_rid;
      val source = init_args.source;

      require(init_args.hops.size() &gt; hop_index);
      require(init_args.hops[hop_index] == my_blockchain_rid);

      val from_chain_rid: byte_array;

      if (hop_index &gt; 0) {
         from_chain_rid = init_args.hops[hop_index - 1];
         
         require(prev_hop);
         verify_transaction_proof(prev_hop);
         require(prev_hop.tx.body.blockchain_rid == from_chain_rid);
         require(prev_hop.tx.body.operations[0].name == "ft3.xc.apply_xfer");
         require(byte_array.from_gtv(prev_hop.tx.body.operations[0].args[0])
              == init_tx_rid);
      } else {
         from_chain_rid = init_tx.tx.body.blockchain_rid;
      }

      val asset = asset @ { .id == source.asset_id };
      val origin_chain_rid = asset_origin @ { asset } .origin_chain_rid;

      // process "from" side
      if (from_chain_rid == origin_chain_rid) {
         // asset comes from origin -- do nothing
      } else {
         deduct_balance(
             get_blockchain_account( from_chain_rid ),
             asset, source.amount
         );
      }

      // process "to" side
      if (init_args.hops.size() &gt; hop_index + 1) {
         // this hop is not last
         val next_hop = init_args.hops[hop_index + 1];
         add_to_blockchain_balance(next_hop, asset, source.amount);
      } else {
         // final hop -- send money to recipient account
         val available_assets = map&lt;asset, integer&gt;();
         available_assets[asset] = source.amount;
         val target = init_args.target;
         process_transfer_output(
                xfer_output(
                  account_id = target.account_id,
                  asset_id = source.asset_id,
                  amount = source.amount,
                  extra = target.extra
                ),
                0,
                available_assets
         );
      }
}</string>
                            </entry>
                            <entry key="lib/ft3/dev_op.rell">
                                <string>// namespace ft3 {

object dev_state {
   mutable allow_dev_ops: boolean = true;   
}

function require_dev() {
    require(dev_state.allow_dev_ops);
}


operation dev_register_asset (name, issuing_chain_rid: byte_array, origin_chain_rid: byte_array) {
    require_dev();
    register_asset(name, issuing_chain_rid);
}

operation dev_give_balance (asset_id: byte_array, account_id: byte_array, amount: integer) {
    require_dev();
    require(amount &gt;= 0);
    ensure_balance( account @ { account_id }, asset @ { .id == asset_id } ).amount += amount;
}

operation dev_register_account (auth_descriptor) {
    require_dev();
    create_account_with_auth( auth_descriptor );
}
</string>
                            </entry>
                            <entry key="lib/ft3/ft3_xc_basic_dev.rell">
                                <string>namespace ft3 {

include "account/auth_basic";
include "core";
include "dev_op";
include "blockchain";

 namespace xc {
    include "crosschain/structures";
    include "crosschain/blockchain";
    include "crosschain/transfer";
    include "crosschain/dev";
 }


}</string>
                            </entry>
                            <entry key="lib/ft3/history.rell">
                                <string>//namespace ft3  {

  class payment_history_entry (log) {
    index account, asset;
    delta: integer;
    
    // helps to locate exact position of payment entry in transaction
    op_index: integer;
    is_input: boolean;
    entry_index: integer;
  }

  query get_payment_history(account_id: byte_array, after_block: integer) {
    return payment_history_entry @* {
        account @ { account_id },
        .transaction.block.block_height &gt; after_block
    } (
        delta = .delta,
        asset = .asset.name,
        asset_id = .asset.id,
        is_input = .is_input,
        timestamp = .transaction.block.timestamp,
        block_height = .transaction.block.block_height,
        tx_rid = .transaction.tx_rid,
        tx_data = .transaction.tx_data
    );
  }
//}</string>
                            </entry>
                            <entry key="lib/ft3/transfer.rell">
                                <string>//namespace ft3 {

record xfer_input {
   account_id: byte_array;
   asset_id: byte_array;
   auth_descriptor_id: byte_array;
   amount: integer;
   extra: map&lt;text, gtv&gt;;
}

record xfer_output {
   account_id: byte_array;
   asset_id: byte_array;
   amount: integer;
   extra: map&lt;text, gtv&gt;;
}

function deduct_balance (account, asset, d_amount: integer) {
    val b = balance @ { account, asset };
    require( b.amount &gt;= d_amount, "Balance is too low");
    update b (amount -= d_amount); 
}

function consume_input (i: xfer_input, idx: integer, assets: map&lt;asset, integer&gt;): payment_history_entry {
      val asset = asset @ { .id == i.asset_id };
      val account = account @ {.id == i.account_id };
      require_auth( account, i.auth_descriptor_id, ["T"] );
      require( i.amount &gt;= 0, "Amount should be positive." );
      
      deduct_balance(account, asset, i.amount);
      assets[asset] = i.amount + if (asset in assets) assets[asset] else 0;
      return create payment_history_entry (
        account,
        asset,
        .delta = i.amount,
        .op_index = 500, //op_context ???
        .is_input = true,
        .entry_index = idx
      );
}

function process_transfer_output (o: xfer_output, idx: integer, available_assets: map&lt;asset, integer&gt;) {
      if (o.extra.contains("reg_auth_desc")) {
          val auth_desc = auth_descriptor.from_gtv(o.extra["reg_auth_desc"]);
          require(o.account_id
           == create_account_with_auth(auth_desc));
      }

      val target_account = account @ { .id == o.account_id };
      val asset = asset @ { .id == o.asset_id };
      require( available_assets[asset] &gt;= o.amount );
      available_assets[asset] -= o.amount;
      require(available_assets[asset] &gt;= 0);
      val balance = ensure_balance(target_account, asset);
      balance.amount += o.amount;

      create payment_history_entry (
        .account = target_account,
        asset,
        .delta = o.amount,

        .op_index = 500, // something from op_context,
        .is_input = false,
        .entry_index = idx
      );
}

operation transfer (inputs: list&lt;xfer_input&gt;, outputs: list&lt;xfer_output&gt;) {
   val sum_inputs = map&lt;asset, integer&gt;();
   var idx = 0;
   for (i in inputs) {
      consume_input(i, idx, sum_inputs);
      idx += 1;
   }

   idx = 0;
   for (o in outputs) {
      process_transfer_output(o, idx, sum_inputs);
      idx += 1;
   }
   
}

 
//}</string>
                            </entry>
                            <entry key="main.rell">
                                <string>// INCLUDE OF FT3 LIBRARY
include 'ft3_config';
include 'lib/ft3/ft3_xc_basic_dev';

include 'util/index';
include 'user/index';
include 'topic/index';
include 'notifications/index';
include 'channel/index';
include 'follow/index';
include 'election/index';
include 'representative/index';
include 'chat/index';
</string>
                            </entry>
                            <entry key="notifications/index.rell">
                                <string>class notification {
    key id: text, user;
    trigger: text;
    content: text;
    mutable read: boolean;
    index timestamp;
}

include 'operations';
include 'queries';</string>
                            </entry>
                            <entry key="notifications/operations.rell">
                                <string>
operation create_notifications_for_users(name, descriptor_id: byte_array, id: text, trigger: text, content: text, usernames: set&lt;text&gt;) {
    val user = get_verified_user(name, descriptor_id);

    for (username in usernames) {
        val toUser = user@?{ .name == username.lower_case() };
        if (toUser != null) {
            create notification(
                id = id, 
                toUser, 
                trigger = trigger,
                content = content,
                false, 
                op_context.last_block_time
            );
        }
    }
}

operation remove_notifications_for_users(name, descriptor_id: byte_array, id: text, usernames: set&lt;text&gt;) {
    val user = get_verified_user(name, descriptor_id);

    for (username in usernames) {
        val to_user = user@?{ .name == username };
        if (to_user != null) {
            delete notification@?{ id, .user == to_user };
        }
    }
}

operation mark_notifications_since_timestamp_read(name, descriptor_id: byte_array, timestamp) {
    val user = get_verified_user(name, descriptor_id);
    update notification@*{ .user == user, .timestamp &gt; timestamp } ( read = true );
}</string>
                            </entry>
                            <entry key="notifications/queries.rell">
                                <string>query count_unread_user_notifications(name) {
    val user = user@{ .name == name };
    return notification@*{ .user == user, .read == false } ( .id );
}

query get_user_notifications_prior_to_timestamp(name, timestamp, page_size: integer) {
    val user = user@{ .name == name };
    return notification@*{ .user == user, .timestamp &lt; timestamp } (
        .id,
        .trigger,
        .content,
        .read,
        -sort .timestamp
    ) limit page_size;
}
</string>
                            </entry>
                            <entry key="representative/index.rell">
                                <string>class representative {
    key user, representative_election;
}

class representative_action {
    key id: byte_array;
    index representative;
    index timestamp;
    action: text;
}

include 'operations';
include 'queries';
include '/representative/report/index';</string>
                            </entry>
                            <entry key="representative/operations.rell">
                                <string>operation remove_topic(username: text, descriptor_id: byte_array, topic_id: text) {
    val user = get_verified_user(username, descriptor_id);

    val recentElection = representative_election@{ .completed == true } ( .id, sort .timestamp );
    val representative = representative @{ user, .representative_election.id == recentElection.id };

    val topic = topic @{ .id == topic_id };
    update topic ( title = "[Removed]", message = "Removed by @" + user.name, removed = true );
    
    create representative_action(
        id = op_context.transaction.tx_rid, 
        representative,
        op_context.last_block_time,
        action = "Topic /t/" + topic.id + " was removed by @" + user.name
    );
}

operation remove_topic_reply(username: text, descriptor_id: byte_array, topic_reply_id: text) {
    val user = get_verified_user(username, descriptor_id);

    val recentElection = representative_election@{ .completed == true } ( .id, sort .timestamp );
    val representative = representative @{ user, .representative_election.id == recentElection.id };

    val reply = topic_reply @{ .id == topic_reply_id };
    update reply ( message = "Removed by @" + user.name, removed = true );

    create representative_action(
        id = op_context.transaction.tx_rid, 
        representative,
        op_context.last_block_time,
        action = "Reply in topic /t/" + reply.topic.id + " was removed by @" + user.name
    );
}

operation suspend_user(username: text, descriptor_id: byte_array, user_to_be_suspended: text) {
    val user = get_verified_user(username, descriptor_id);

    val recentElection = representative_election@{ .completed == true } ( .id, sort .timestamp );
    val representative = representative @{ user, .representative_election.id == recentElection.id };

    val suspendee = user@{ .name == user_to_be_suspended };
    val suspendee_meta = user_meta@{ suspendee };

    require(
    	suspendee_meta.suspended_until &lt; op_context.last_block_time, 
    	app_error(error_type.REPRESENTATIVE_ALREADY_SUSPENDED, "Suspend user")
    );

    val updatedTimesSuspended = suspendee_meta.times_suspended + 1;
    val oneDayMillis = 86400000;
    val daysSuspended = updatedTimesSuspended * updatedTimesSuspended;
    val suspensionTimeMillis = daysSuspended * oneDayMillis;

    update suspendee_meta ( 
        suspended_until = op_context.last_block_time + suspensionTimeMillis, 
        times_suspended = updatedTimesSuspended
    );

    var daysString = " days ";
    if (daysSuspended == 1) {
        daysString = " day ";
    }

    create representative_action(
        id = op_context.transaction.tx_rid, 
        representative,
        op_context.last_block_time,
        action = "@" + suspendee.display_name + " was suspended for " + daysSuspended + daysString +  "by @" + user.display_name
    );
}

operation tmp_add_representative(admin_name: name, descriptor_id: byte_array, name) {
    val admin_user = get_verified_user(admin_name, descriptor_id);
    admin@{ admin_user };

    val currentElection = representative_election @ { .timestamp &lt;= op_context.last_block_time, .completed == true } (
        .id,
        -sort .timestamp
    ) limit 1;

    create representative(user@{ .name == name }, representative_election@{ .id == currentElection.id });
}

operation tmp_remove_representative(admin_name: name, descriptor_id: byte_array, name) {
    val admin_user = get_verified_user(admin_name, descriptor_id);
    admin@{ admin_user };

    val currentElection = representative_election @ { .timestamp &lt;= op_context.last_block_time, .completed == true } (
        .id,
        -sort .timestamp
    ) limit 1;

    delete representative @?{ user@{ .name == name }, representative_election@{ .id == currentElection.id }};
}</string>
                            </entry>
                            <entry key="representative/queries.rell">
                                <string>query get_representatives() {
    val election = representative_election@?{ .completed == true } ( .id, -sort .timestamp ) limit 1;

    // If no election yes, then admin is technically the only representative
    if (election == null) {
        return ["admin"];
    }

    return representative@*{
        .representative_election.id == election.id
    } ( .user.name );
}

query get_all_representative_actions(timestamp, page_size: integer) {
    return representative_action@*{
        .timestamp &lt; timestamp
    } ( 
        .id, 
        representative = .representative.user.name, 
        -sort .timestamp, 
        .action 
    ) limit page_size;
}

query get_number_of_times_representative(name) {
    return representative@*{ .user.name == name } ( .representative_election.id ).size();
}</string>
                            </entry>
                            <entry key="representative/report/index.rell">
                                <string>class representative_report {
    key id: text;
    index user;
    index timestamp;
    mutable handled: boolean;
    index handled;
    text;
}

include 'operations';
include 'queries';</string>
                            </entry>
                            <entry key="representative/report/operations.rell">
                                <string>operation create_representative_report(username: text, descriptor_id: byte_array, id: text, text) {
    val user = get_verified_user(username, descriptor_id);
    require(user_meta@{ user }.suspended_until &lt; op_context.last_block_time);

    create representative_report(id= id, user, op_context.last_block_time, false, text = text);
}

operation handle_representative_report(username: text, descriptor_id: byte_array, id: text) {
    val user = get_verified_user(username, descriptor_id);

    val recentElection = representative_election@{ .completed == true } ( .id, sort .timestamp );
    val representative = representative @{ user, .representative_election.id == recentElection.id };

    val report = representative_report@{ .id == id };
    update report ( handled = true );

    create representative_action(
        id = op_context.transaction.tx_rid, 
        representative,
        op_context.last_block_time,
        action = "Report: '" + report.text + "' was handled by @" + user.name
    );
}</string>
                            </entry>
                            <entry key="representative/report/queries.rell">
                                <string>query get_unhandled_representative_reports() {
    return representative_report@*{ .handled == false } ( .id, user = .user.name, -sort .timestamp, .handled, .text );
}</string>
                            </entry>
                            <entry key="topic/functions.rell">
                                <string>function find_topic_by_id(id: text): topic {
    return topic@{ .id == id };
}

function require_mutable(post_timestamp: timestamp, op_timestamp: timestamp, action: text) {
	val fiveMinutesInMillis = 300000;
    require(
    	op_timestamp &lt; post_timestamp + fiveMinutesInMillis,
    	app_error(error_type.TOPIC_IMMUTABLE, action)
    );
}</string>
                            </entry>
                            <entry key="topic/index.rell">
                                <string>class topic {
    key id: text;
    index author: user;
    timestamp;
    mutable last_modified: timestamp;
    index last_modified;
    mutable title: name;
    mutable message: text;
    mutable removed: boolean = false;
    index removed;
}

class topic_reply {
    key id: text;
    index topic;
    index author: user;
    index timestamp;
    is_sub_reply: boolean = false;
    index is_sub_reply;
    mutable message: text;
    mutable removed: boolean = false;
}

class sub_reply {
    key parent_reply: topic_reply, child_reply: topic_reply;
}

include 'functions';
include 'operations';
include 'queries';
include '/topic/rating/index';
include '/topic/subscription/index';</string>
                            </entry>
                            <entry key="topic/operations.rell">
                                <string>operation create_topic(id: text, descriptor_id: byte_array, username: text, channel_key: name, channel_name: name, title: name, message: text) {
    val author = get_verified_user(username, descriptor_id);
    
    val topic = create topic(
        id = id, 
        author,
        timestamp = op_context.last_block_time,
        last_modified = op_context.last_block_time,
        title = title,
        message = message
    );

    create channel(name = channel_key.lower_case(), topic, op_context.last_block_time, display_name = channel_name);
    create tmp_topic_rating (topic, 0);
}

operation modify_topic(id: text, descriptor_id: byte_array, username: text, text) {
    val author = get_verified_user(username, descriptor_id);

    val topic = topic@{ .id == id, .author == author };
    require_mutable(topic.timestamp, op_context.last_block_time, "Modify topic");
    
    update topic ( message = text );
}

operation delete_topic(id: text, descriptor_id: byte_array, username: text) {
     val author = get_verified_user(username, descriptor_id);

     val topic = topic@{ .id == id, .author == author };
     require_mutable(topic.timestamp, op_context.last_block_time, "Delete topic");
     
     update topic ( removed = true, message = "Deleted by @" + username );
}

operation create_reply(topic_id: text, descriptor_id: byte_array, id: text, username: text, message: text) {
    val author = get_verified_user(username, descriptor_id);
    val topic = find_topic_by_id(topic_id);

    create topic_reply(
        id = id,
        topic,
        author,
        timestamp = op_context.last_block_time,
        message = message
    );

    if (not topic.removed) {
        update topic ( last_modified = op_context.last_block_time);
    }
}

operation modify_reply(id: text, descriptor_id: byte_array, username: text, text) {
    val author = get_verified_user(username, descriptor_id);

    val reply = topic_reply@{ .id == id, .author == author };
    require_mutable(reply.timestamp, op_context.last_block_time, "Modify reply");
    
    update reply ( message = text );
}

operation create_sub_reply(topic_id: text, descriptor_id: byte_array, parent_reply_id: text, id: text, username: text, message: text) {
    val author = get_verified_user(username, descriptor_id);
    val topic = find_topic_by_id(topic_id);

    val topic_reply = create topic_reply(
        id = id,
        topic,
        author,
        timestamp = op_context.last_block_time,
        is_sub_reply = true,
        message = message
    );

    create sub_reply(
        parent_reply = topic_reply@{ .id == parent_reply_id },
        child_reply = topic_reply
    );

    if (not topic.removed) {
        update topic ( last_modified = op_context.last_block_time);
    }
}</string>
                            </entry>
                            <entry key="topic/queries.rell">
                                <string>query get_topics_after_timestamp(timestamp, page_size: integer) {
    return topic @* { 
        .last_modified &gt; timestamp,
        .removed == false
    }(
        .id,
        author=.author.display_name,
        .title,
        .message,
        -sort .last_modified,
        .removed,
        .timestamp
    ) limit page_size;
}

query get_topics_prior_to_timestamp(timestamp, page_size: integer) {
    return topic @* { 
        .last_modified &lt; timestamp,
        .removed == false
    }(
        .id,
        author=.author.display_name,
        .title,
        .message,
        -sort .last_modified,
        .removed,
        .timestamp
    ) limit page_size;
}

query get_topic_replies_prior_to_timestamp(topic_id: text, timestamp, page_size: integer) {
    return topic_reply@*{
        topic@{ .id == topic_id },
        .timestamp &lt; timestamp,
        .is_sub_reply == false
    }(
        .id,
        topic_id = .topic.id,
        author=.author.display_name,
        .message,
        .is_sub_reply,
        .removed,
        -sort .timestamp
    ) limit page_size;
}

query get_topic_replies_after_timestamp(topic_id: text, timestamp, page_size: integer) {
    return topic_reply@*{
        topic@{ .id == topic_id },
        .timestamp &gt; timestamp,
        .is_sub_reply == false
    }(
        .id,
        topic_id = .topic.id,
        author=.author.display_name,
        .message,
        .is_sub_reply,
        .removed,
        -sort .timestamp
    ) limit page_size;
}

query get_topic_replies_by_user_prior_to_timestamp(name, timestamp, page_size: integer) {
    return topic_reply@*{ .author.name == name, .timestamp &lt; timestamp } (
        .id,
        topic_id = .topic.id,
        author=.author.display_name,
        .message,
        .is_sub_reply,
        .removed,
        -sort .timestamp
    ) limit page_size;
}

query count_topics_by_user(name): integer {
    return topic@*{ .author.name == name }( .id ).size();
}

query count_replies_by_user(name): integer {
    return topic_reply@*{ .author.name == name }( .id ).size();
}

query get_sub_replies(parent_reply_id: text) {
    return sub_reply@*{ .parent_reply.id == parent_reply_id } (
        id=.child_reply.id,
        author=.child_reply.author.display_name,
        message=.child_reply.message,
        is_sub_reply=.child_reply.is_sub_reply,
        removed = .child_reply.removed,
        sort timestamp=.child_reply.timestamp
    );
}

query get_topics_by_user_id_prior_to_timestamp(name, timestamp, page_size: integer) {
    return topic@*{
        user@{ .name == name },
        .last_modified &lt; timestamp
    }(
        .id,
        author=.author.display_name,
        .title,
        .message,
        -sort .last_modified,
        .removed,
        .timestamp
    ) limit page_size;
}

query get_topics_from_follows_after_timestamp(name, timestamp, page_size: integer) {
    return (topic, follow) @* {
            follow.follower.name == name.lower_case(),
            follow.follows == topic.author,
            topic.last_modified &gt; timestamp,
            topic.removed == false
    }(
        topic.id,
        author=topic.author.display_name,
        topic.title,
        topic.message,
        topic.removed,
        -sort topic.last_modified,
        topic.timestamp
    ) limit page_size;
}

query get_topics_from_follows_prior_to_timestamp(name, timestamp, page_size: integer) {
    return (topic, follow) @* {
        follow.follower.name == name.lower_case(),
        follow.follows == topic.author,
        topic.last_modified &lt; timestamp,
        topic.removed == false
    }(
        topic.id,
        author=topic.author.display_name,
        topic.title,
        topic.message,
        topic.removed,
        -sort topic.last_modified,
        topic.timestamp
    ) limit page_size;
}

query get_topic_by_id(id: text) {
    return topic@{
        .id == id
    }(
        .id,
        author=.author.display_name,
        .title,
        .message,
        .removed,
        -sort .last_modified,
        .timestamp
    );
}

query get_all_topics_by_stars_since_timestamp(timestamp, page_size: integer) {
    return tmp_topic_rating@*{
        .topic.last_modified &gt; timestamp,
        .topic.removed == false
    } (
        -sort .stars,
        id = .topic.id,
        author=.topic.author.display_name,
        title=.topic.title,
        message=.topic.message,
        last_modified=.topic.last_modified,
        timestamp=.topic.timestamp,
        removed=.topic.removed
    ) limit page_size;
}

query get_topics_by_follows_and_stars_since_timestamp(name, timestamp, page_size: integer) {
    return (tmp_topic_rating, follow) @*{
            follow.follower.name == name,
            tmp_topic_rating.topic.author == follow.follows,
            tmp_topic_rating.topic.last_modified &gt; timestamp,
            tmp_topic_rating.topic.removed == false
        } (
        -sort tmp_topic_rating.stars,
        id = tmp_topic_rating.topic.id,
        author=tmp_topic_rating.topic.author.display_name,
        title=tmp_topic_rating.topic.title,
        message=tmp_topic_rating.topic.message,
        last_modified=tmp_topic_rating.topic.last_modified,
        timestamp=tmp_topic_rating.topic.timestamp,
        removed=tmp_topic_rating.topic.removed
    ) limit page_size;
}

query get_topics_by_channel_after_timestamp_sorted_by_popularity(name, timestamp, page_size: integer) {
    return (tmp_topic_rating, channel)@*{
        name == channel.name,
        tmp_topic_rating.topic == channel.topic,
        tmp_topic_rating.topic.last_modified &gt; timestamp,
        tmp_topic_rating.topic.removed == false
    } (
        -sort .stars,
        id = channel.topic.id,
        author=channel.topic.author.display_name,
        title=channel.topic.title,
        message=channel.topic.message,
        last_modified=channel.topic.last_modified,
        timestamp=channel.topic.timestamp,
        removed=channel.topic.removed
    ) limit page_size;
}

query get_topics_by_followed_channels_after_timestamp_sorted_by_popularity(name, timestamp, page_size: integer) {
    return (tmp_topic_rating, channel_following, channel)@*{
        channel_following.user == user@{ name },
        channel_following.name == channel.name,
        tmp_topic_rating.topic == channel.topic,
        tmp_topic_rating.topic.last_modified &gt; timestamp,
        tmp_topic_rating.topic.removed == false
    } (
        -sort .stars,
        id = channel.topic.id,
        author=channel.topic.author.display_name,
        title=channel.topic.title,
        message=channel.topic.message,
        last_modified=channel.topic.last_modified,
        timestamp=channel.topic.timestamp,
        removed=channel.topic.removed
    ) limit page_size;
}</string>
                            </entry>
                            <entry key="topic/rating/index.rell">
                                <string>class topic_star_rating {
    key topic, user;
}

// To be deleted when GROUP BY and COUNT is supported, then will use topic_star_rating instead
class tmp_topic_rating {
    key topic;
    mutable stars: integer;
    index stars;
}

class reply_star_rating {
    key topic_reply, user;
}

include 'operations';
include 'queries';</string>
                            </entry>
                            <entry key="topic/rating/operations.rell">
                                <string>operation give_topic_star_rating(username: text, descriptor_id: byte_array, id: text, unique_id: text) {
    val user = get_verified_user(username, descriptor_id);
    create topic_star_rating(topic@{ .id == id }, user);

    val topicRating = tmp_topic_rating@{ topic@{ .id == id }};
    update topicRating ( stars = topicRating.stars + 1 );
}

operation remove_topic_star_rating(username: text, descriptor_id: byte_array, id: text, unique_id: text) {
    val user = get_verified_user(username, descriptor_id);
    delete topic_star_rating@{ topic@{ .id == id }, user };

    val topicRating = tmp_topic_rating@{ topic@{ .id == id }};
    update topicRating ( stars = topicRating.stars - 1 );
}

operation give_reply_star_rating(username: text, descriptor_id: byte_array, id: text, unique_id: text) {
    val user = get_verified_user(username, descriptor_id);
    create reply_star_rating(topic_reply@{ .id == id }, user);
}

operation remove_reply_star_rating(username: text, descriptor_id: byte_array, id: text, unique_id: text) {
    val user = get_verified_user(username, descriptor_id);
    delete reply_star_rating@{ topic_reply@{ .id == id }, user };
}</string>
                            </entry>
                            <entry key="topic/rating/queries.rell">
                                <string>query get_star_rating_for_topic(id: text) {
    return topic_star_rating@*{ topic@{ .id == id }} ( .user.name );
}

query get_star_rating_for_reply(id: text) {
    return reply_star_rating@*{ topic_reply@{ .id == id }} ( .user.name );
}

query count_user_topic_star_rating(name): integer {
    return topic_star_rating@*{ .topic.author.name == name } ( .topic, .user ).size();
}

query count_user_reply_star_rating(name): integer {
    return reply_star_rating@*{ .topic_reply.author.name == name } ( .topic_reply, .user ).size();
}</string>
                            </entry>
                            <entry key="topic/subscription/index.rell">
                                <string>class subscription {
    key topic, user;
}

include 'operations';
include 'queries';</string>
                            </entry>
                            <entry key="topic/subscription/operations.rell">
                                <string>operation subscribe_to_topic(username: text, descriptor_id: byte_array, id: text, unique_id: text) {
    val user = get_verified_user(username, descriptor_id);
    create subscription(topic@{ .id == id }, user);
}

operation unsubscribe_from_topic(username: text, descriptor_id: byte_array, id: text, unique_id: text) {
    val user = get_verified_user(username, descriptor_id);
    delete subscription@{ topic@{ .id == id }, user };
}</string>
                            </entry>
                            <entry key="topic/subscription/queries.rell">
                                <string>query get_subscribers_for_topic(id: text) {
    return subscription@*{ topic@{ .id == id }} ( .user.name );
}</string>
                            </entry>
                            <entry key="user/functions.rell">
                                <string>function get_verified_user(name, descriptor_id: byte_array): user {
    val user = user@{ .name == name.lower_case() };
    ft3.require_auth(user.account, descriptor_id, ["A"]);
    require(
    	user_meta@{ user }.suspended_until &lt; op_context.last_block_time, 
    	app_error(error_type.USER_SUSPENDED, "Get verified user")
    );

    return user;
}

function assert_admin(user) {
	require(admin@?{ user }, app_error(error_type.USER_UNAUTHORIZED, "Assert admin"));
}</string>
                            </entry>
                            <entry key="user/index.rell">
                                <string>class admin {
    user;
}

class user {
    key account: ft3.account, name;
    display_name: name;
}

include 'functions';
include 'operations';
include 'queries';
include '/user/settings/index';
include '/user/meta/index';
include '/user/mute/index';</string>
                            </entry>
                            <entry key="user/meta/index.rell">
                                <string>class user_meta {
    key user;
    mutable times_suspended: integer;
    mutable suspended_until: timestamp;
}

include 'operations';
include 'queries';</string>
                            </entry>
                            <entry key="user/meta/operations.rell">
                                <string></string>
                            </entry>
                            <entry key="user/meta/queries.rell">
                                <string>query get_user_meta(name) {
    return user_meta@{ user@{ name }} ( 
        name = .user.name, 
        times_suspended = .times_suspended, 
        suspended_until = .suspended_until 
    );
}</string>
                            </entry>
                            <entry key="user/mute/index.rell">
                                <string>class user_mute {
    key user, muted_user: user;
}

include 'operations';
include 'queries';</string>
                            </entry>
                            <entry key="user/mute/operations.rell">
                                <string>operation toggle_mute(username: name, descriptor_id: byte_array, name, muted: boolean) {
    val user = get_verified_user(username, descriptor_id);

    if (muted) {
        create user_mute(user = user, muted_user = user@{ .name == name });
    } else {
        delete user_mute@{ .user == user, .muted_user == user@{ .name == name }};
    }
}</string>
                            </entry>
                            <entry key="user/mute/queries.rell">
                                <string>query get_muted_users(username: name) {
    return user_mute@*{ .user.name == username } ( .muted_user.name );
}</string>
                            </entry>
                            <entry key="user/operations.rell">
                                <string>operation register_user(name, auth_descriptor: ft3.auth_descriptor, vault_auth_descriptor: ft3.auth_descriptor) {
    val account_id = ft3.create_account_with_auth(auth_descriptor);
    val account = ft3.account @ { account_id };
    ft3._add_auth_descriptor(account, vault_auth_descriptor);

    if (name == "admin") {
        val admin = create user(name = name.lower_case(), display_name = name, account);
        create admin(admin);
        create user_settings(admin, avatar = "" , description = "");
        create user_meta(admin, times_suspended = 0, suspended_until = 0);
    } else {
        val user = create user(name = name.lower_case(), display_name = name, account);
        create user_settings(user, avatar = "" , description = "");
        create user_meta(user, times_suspended = 0, suspended_until = 0);
    }
}</string>
                            </entry>
                            <entry key="user/queries.rell">
                                <string>query get_user(name) {
    return user@?{ .name == name.lower_case() } ( name = .display_name );
}

query get_account_id(name) {
    return user@?{ .name == name.lower_case() } ( .account.id );
}</string>
                            </entry>
                            <entry key="user/settings/index.rell">
                                <string>class user_settings {
    key user;
    mutable avatar: text;
    mutable description: text;
}

include 'operations';
include 'queries';</string>
                            </entry>
                            <entry key="user/settings/operations.rell">
                                <string>operation create_user_settings(name, descriptor_id: byte_array, avatar: text, description: text) {
    val user = get_verified_user(name, descriptor_id);
    create user_settings(user, avatar = avatar, description = description);
}

operation update_user_settings(name, descriptor_id: byte_array, avatar: text, description: text) {
    val user = get_verified_user(name, descriptor_id);
    update user_settings@{ .user == user }( avatar = avatar, description = description );
}</string>
                            </entry>
                            <entry key="user/settings/queries.rell">
                                <string>query get_user_settings(name) {
    return user_settings@?{ user@{ .name == name }} ( .avatar, .description );
}</string>
                            </entry>
                            <entry key="util/index.rell">
                                <string>include 'log';</string>
                            </entry>
                            <entry key="util/log.rell">
                                <string>enum error_type {
	USER_UNAUTHORIZED,
	USER_SUSPENDED,
	TOPIC_IMMUTABLE,
	REPRESENTATIVE_ALREADY_SUSPENDED,
	ILLEGAL_ACTION
}

function app_error(error_type, action: text): text {
	val msg = when(error_type) {
		USER_UNAUTHORIZED -&gt; message_with_code("CERR_10", "Requester was unauthorized", action);
		USER_SUSPENDED -&gt; message_with_code("CERR_11", "Requester was suspended", action);
		TOPIC_IMMUTABLE -&gt; message_with_code("CERR_20", "Topic is no longer mutable", action);
		REPRESENTATIVE_ALREADY_SUSPENDED -&gt; message_with_code("CERR_30", "User was already suspended", action);
		ILLEGAL_ACTION -&gt; message_with_code("CERR_40", "The attempted action was illegal", action);
	};
	
	log(msg);
	return msg;
}

function message_with_code(code: text, message: text, action: text): text {
	return '{"code":"' + code + '","message":"' + message + '","action":"' + action + '"}';
}</string>
                            </entry>
                        </dict>
                    </entry>
                </dict>
            </entry>
        </dict>
    </entry>
    <entry key="signers">
        <array>
            <bytea>0350FE40766BC0CE8D08B3F5B810E49A8352FDD458606BD5FAFE5ACDCDC8FF3F57</bytea>
        </array>
    </entry>
</dict>
