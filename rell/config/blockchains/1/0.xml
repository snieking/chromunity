<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<dict>
    <entry key="blockstrategy">
        <dict>
            <entry key="blockdelay">
                <int>750</int>
            </entry>
            <entry key="maxblocktime">
                <int>15000</int>
            </entry>
            <entry key="maxblocktransactions">
                <int>500</int>
            </entry>
            <entry key="name">
                <string>net.postchain.base.BaseBlockBuildingStrategy</string>
            </entry>
        </dict>
    </entry>
    <entry key="configurationfactory">
        <string>net.postchain.gtx.GTXBlockchainConfigurationFactory</string>
    </entry>
    <entry key="gtx">
        <dict>
            <entry key="modules">
                <array>
                    <string>net.postchain.rell.module.RellPostchainModuleFactory</string>
                    <string>net.postchain.gtx.StandardOpsGTXModule</string>
                </array>
            </entry>
            <entry key="rell">
                <dict>
                    <entry key="mainFile">
                        <string>main.rell</string>
                    </entry>
                    <entry key="sources_v0.9">
                        <dict>
                            <entry key="channel/index.rell">
                                <string>class channel {
    key name, topic;
    index timestamp;
    display_name: name;
}

class channel_following {
    key user, name;
}

include 'operations';
include 'queries';</string>
                            </entry>
                            <entry key="channel/operations.rell">
                                <string>operation follow_channel(username: text, name) {
    val user = get_verified_user(username);
    // TODO: .lower_case() on Rell 0.9
    create channel_following(user, name);
}

operation unfollow_channel(username: text, name) {
    val user = get_verified_user(username);
    // TODO: .lower_case() on Rell 0.9
    delete channel_following@{ user, name};
}</string>
                            </entry>
                            <entry key="channel/queries.rell">
                                <string>query get_topics_by_channel_prior_to_timestamp(name, timestamp, page_size: integer) {
    // TODO: .lower_case() in Rell 0.9
    return channel@*{ 
        .name == name,
        .topic.last_modified &lt; timestamp
    } (
        id=.topic.id,
        author=.topic.author.display_name,
        title=.topic.title,
        message=.topic.message,
        timestamp=.topic.timestamp,
        -sort last_modified=.topic.last_modified
    ) limit page_size;
}

query get_topics_by_channel_after_timestamp(name, timestamp) {
    return channel@*{ 
        .name == name,
        .topic.last_modified &gt; timestamp
    } (
        id=.topic.id,
        author=.topic.author.display_name,
        title=.topic.title,
        message=.topic.message,
        timestamp=.topic.timestamp,
        -sort last_modified=.topic.last_modified
    );
}

query count_topics_by_channel(name) {
    return channel@*{ .name == name } ( .name ).size();
}

query count_channel_followers(name) {
    return channel_following@*{ .name == name } ( .user.name ).size();
}

query get_topics_by_followed_channels_prior_to_timestamp(username: text, timestamp, page_size: integer) {
    val user = user@{ .name == username};
    return (channel, channel_following) @* {
        channel_following.user == user,
        channel_following.name == channel.name,
        channel.topic.last_modified &lt; timestamp
    }
    (
        id=channel.topic.id,
        author=channel.topic.author.display_name,
        title=channel.topic.title,
        message=channel.topic.message,
        timestamp=channel.topic.timestamp,
        -sort last_modified=channel.topic.last_modified
    ) limit page_size;
}

query get_followed_channels(username: text) {
    val user = user@{ .name == username};
    return channel_following@*{ user } ( .name );
}

query get_all_channels() {
    return channel@*{} ( .display_name );
}

query get_channels_since(timestamp) {
    return channel@*{ .timestamp &gt; timestamp }( .display_name );
}

query get_topic_channels_belongings(topic_id: text) {
    return channel@*{ topic@{ .id == topic_id }} ( .display_name );
}
</string>
                            </entry>
                            <entry key="election/index.rell">
                                <string>class representative_election {
    key id: text;
    index timestamp;
    mutable completed: boolean;
    index completed;
}

class representative_election_candidate {
  key representative_election, user;
}

class representative_election_vote {
    key user, representative_election_candidate;
}

include 'operations';
include 'queries';</string>
                            </entry>
                            <entry key="election/operations.rell">
                                <string>operation trigger_election(admin_user: text, id: text, timestamp) {
    require(is_signer(admin@{ .user.name == admin_user}( .user.pubkey )));

    val currentElection = representative_election @? { .completed == false };

    if (currentElection == null) {
        create representative_election(id, timestamp, false);
    }
}
  
operation complete_election(admin_user: text, representatives: set&lt;text&gt;) {
    require(is_signer(admin@{ .user.name == admin_user}( .user.pubkey )));

    val currentElection = representative_election @ { .completed == false };
    log("Completing election: ", currentElection.id);
    update currentElection ( completed = true );

    for (representative in representatives) {
        val user = user@{ .name == representative };
        create representative(user, currentElection);
    }
}

operation vote_for_candidate(voter: name, candidate: name) {
    val user = get_verified_user(voter);

    val currentElection = representative_election @ { .completed == false };
    log("Voting for candidate in election: ", currentElection.id);
    create representative_election_vote(
        user,
        representative_election_candidate@{ user@{ .name == candidate }, currentElection }
    );
}

operation update_vote_for_candidate(voter: name, candidate: name) {
    val user = get_verified_user(voter);

    val currentElection = representative_election @ { .completed == false };    
    val election_candidate = representative_election_candidate@{
        currentElection,
        user@{ .name == candidate }
    };

    delete representative_election_vote@?{
        .user == user,
        election_candidate
    };

    create representative_election_vote(
        user,
        representative_election_candidate@{
            .user.name == candidate,
            currentElection
        }
    );
}

operation sign_up_for_election(name) {
    val user = get_verified_user(name);

    val currentElection = representative_election @ { .completed == false };

    create representative_election_candidate(currentElection, user);
}</string>
                            </entry>
                            <entry key="election/queries.rell">
                                <string>query get_election_votes() {
    return representative_election_vote@*{
        representative_election_candidate@{ 
            representative_election @ { .completed == false }
        }
    } ( .representative_election_candidate.user.name );
}

query get_election_candidates() {
    return representative_election_candidate@*{
        representative_election @ { .completed == false }
    } ( .user.name );
}

query get_next_election(timestamp) {
    return representative_election@?{ .timestamp &gt; timestamp } ( .id, -sort .timestamp ) limit 1;
}

query get_uncompleted_election() {
    return representative_election@?{
        .completed == false
    } ( .id );
}

query get_user_vote_in_election(name) {
    return representative_election_vote@?{
        .user == user@{ .name == name },
        .representative_election_candidate.representative_election == representative_election @ { .completed == false }
    } ( .representative_election_candidate.user.name );
}

query get_current_representative_period(timestamp) {
    return representative_election @? { .timestamp &lt;= timestamp, .completed == true } ( .id, -sort .timestamp ) limit 1;
}</string>
                            </entry>
                            <entry key="follow/index.rell">
                                <string>class follow {
    key follower: user, follows: user;
}

include 'operations';
include 'queries';</string>
                            </entry>
                            <entry key="follow/operations.rell">
                                <string>operation create_following(follower: text, follows: text) {
    require(follower != follows);
    val user = get_verified_user(follower);
    create follow(follower = user, follows = user@{ .name == follows });
}

operation remove_following(follower: text, follows: text) {
    require(follower != follows);
    val user = get_verified_user(follower);

    delete follow@{ .follower == user, .follows == user@{ .name == follows } };
}
</string>
                            </entry>
                            <entry key="follow/queries.rell">
                                <string>
query get_user_followers(name) {
    return follow@*{ .follows == user @ { .name == name } }( .follower.name );
}

query get_user_follows(name) {
    return follow@*{ .follower == user@{ .name == name } } ( .follows.name );
}
</string>
                            </entry>
                            <entry key="lib/ft3/account/auth_basic.rell">
                                <string>//namespace ft3 {

// Auth type:

// "S" - single-sig
// "M" - multi-sig

record single_sig_args {
       flags: set&lt;text&gt;;
       pubkey;
}

record multi_sig_args {
       flags: set&lt;text&gt;;
       signatures_required: integer;
       pubkeys: list&lt;pubkey&gt;;
}

function check_single_sig_auth(args: byte_array, required_flags: list&lt;text&gt;): boolean {
    val ss_args = single_sig_args.from_bytes(args);
    return
          ss_args.flags.contains_all(required_flags)
            and 
          is_signer(ss_args.pubkey); 
}

function check_multi_sig_auth(args: byte_array, required_flags: list&lt;text&gt;): boolean {
   val multi_sign_args = multi_sig_args.from_bytes(args);
   if (not (multi_sign_args.flags.contains_all(required_flags))) return false;
   var num_sign = multi_sign_args.signatures_required;
   for(s in multi_sign_args.pubkeys) {
      if(is_signer(s)) {
          num_sign -= 1;
          if(num_sign &lt; 1) {return true;}
      }
   }
   return false;
}

function check_auth_args (a_t: text, args: byte_array, required_flags: list&lt;text&gt;): boolean {
    return when (a_t) {
        "S" -&gt; check_single_sig_auth(args, required_flags);
        "M" -&gt; check_multi_sig_auth(args, required_flags);
        else -&gt; false;
    };
}


function require_auth (account, descriptor_id: byte_array, required_flags: list&lt;text&gt;) {
   val account_auth_descriptor = account_auth_descriptor @ {
     account,
     .descriptor_id == descriptor_id
   };
   require(
      check_auth_args(
       account_auth_descriptor.auth_type,
       account_auth_descriptor.args,
       required_flags
       )
   );  
}


//}</string>
                            </entry>
                            <entry key="lib/ft3/account/main.rell">
                                <string>// namespace ft3 {

record auth_descriptor {
    auth_type: text;
    args: list&lt;gtv&gt;;
}

class account {
    key id: byte_array;      
}

class account_meta {
    meta_key: text;
    value: byte_array;
    index account, meta_key;
    index meta_key, value;
}

class account_auth_descriptor {
     descriptor_id: byte_array;
     key account, descriptor_id;
     index descriptor_id;
     auth_type: text;
     args: byte_array;
}

function _add_auth_descriptor (account, auth_descriptor) {
     val descriptor_id = auth_descriptor.hash();
     create account_auth_descriptor (
        account, descriptor_id,
        auth_descriptor.auth_type,
        args = auth_descriptor.args.to_gtv().to_bytes()
     );
}

function create_account_with_auth (auth_descriptor): byte_array {
     val id = auth_descriptor.hash();
     val acc = create account (id);
     _add_auth_descriptor(
        acc, auth_descriptor
     );
     return id;
}

operation delete_auth_descriptor (account_id: byte_array, auth_descriptor_id: byte_array, delete_descriptor_id: byte_array) {
      val account = account @ { .id == account_id };
      require_auth(account, auth_descriptor_id, ["A"]);
      delete account_auth_descriptor @ {
         .account == account,
         .descriptor_id == delete_descriptor_id
      };
}

operation add_auth_descriptor (account_id: byte_array, auth_id: byte_array, new_desc: auth_descriptor) {
      val account = account @ { .id == account_id };
      require_auth(account, auth_id, ["A"]);
      _add_auth_descriptor(account, new_desc);
}

</string>
                            </entry>
                            <entry key="lib/ft3/asset.rell">
                                <string>//namespace ft3 {
  class asset {
    id: byte_array;
    key id;
    name;
    issuing_chain_rid: byte_array;
    key name, issuing_chain_rid;
  }

  class balance {
    key account, asset;
    mutable amount: integer = 0;
  }

  function ensure_balance(account, asset): balance {
    val balance = balance @? {asset, account};
    if (balance != null) {
       return balance;
    }
    else return create balance(account, asset, amount = 0);
  }

  function register_asset (name, issuing_chain_rid: byte_array): asset {
  print("HELLO");
    print(11111, name.hash());
    print(22222, issuing_chain_rid.hash());
   val id = (name, issuing_chain_rid).hash();
   return create asset (id, name, issuing_chain_rid);
  }


   query get_asset_by_name_and_chain(name, issuing_chain_rid: text) {
        return asset@{name, .issuing_chain_rid ==byte_array(issuing_chain_rid)}.id;
   }

// }

</string>
                            </entry>
                            <entry key="lib/ft3/core.rell">
                                <string>include "account/main";
include "account/auth_basic";
include "asset";
include "history";
include "transfer";</string>
                            </entry>
                            <entry key="lib/ft3/ft3_basic.rell">
                                <string>namespace ft3 {

include "account/auth_basic";
include "core";

}</string>
                            </entry>
                            <entry key="lib/ft3/history.rell">
                                <string>//namespace ft3  {

  class payment_history_entry (log) {
    index account, asset;
    delta: integer;
    
    // helps to locate exact position of payment entry in transaction
    op_index: integer;
    is_input: boolean;
    entry_index: integer;
    
  }

  

//}</string>
                            </entry>
                            <entry key="lib/ft3/transfer.rell">
                                <string>//namespace ft3 {

record xfer_input {
   account_id: byte_array;
   asset_id: byte_array;
   auth_descriptor_id: byte_array;
   amount: integer;
   extra: map&lt;text, gtv&gt;;
}

record xfer_output {
   account_id: byte_array;
   asset_id: byte_array;
   amount: integer;
   extra: map&lt;text, gtv&gt;;
}

function deduct_balance (account, asset, d_amount: integer) {
    val b = balance @ { account, asset };
    require( b.amount &gt;= d_amount, "Balance is too low");
    update b (amount -= d_amount); 
}

function consume_input (i: xfer_input, idx: integer, assets: map&lt;asset, integer&gt;): payment_history_entry {
      val asset = asset @ { .id == i.asset_id };
      val account = account @ {.id == i.account_id };
      require_auth( account, i.auth_descriptor_id, ["T"] );
      require( i.amount &gt;= 0, "Amount should be positive." );
      
      deduct_balance(account, asset, i.amount);
      assets[asset] = i.amount + if (asset in assets) assets[asset] else 0;
      return create payment_history_entry (
        account,
        asset,
        .delta = i.amount,
        .op_index = 500, //op_context ???
        .is_input = true,
        .entry_index = idx
      );
}

function process_transfer_output (o: xfer_output, idx: integer, available_assets: map&lt;asset, integer&gt;) {
      if (o.extra.contains("reg_auth_desc")) {
          val auth_desc = auth_descriptor.from_gtv(o.extra["reg_auth_desc"]);
          require(o.account_id
           == create_account_with_auth(auth_desc));
      }

      val target_account = account @ { .id == o.account_id };
      val asset = asset @ { .id == o.asset_id };
      require( available_assets[asset] &gt;= o.amount );
      available_assets[asset] -= o.amount;
      require(available_assets[asset] &gt;= 0);
      val balance = ensure_balance(target_account, asset);
      balance.amount += o.amount;

      create payment_history_entry (
        .account = target_account,
        asset,
        .delta = o.amount,

        .op_index = 500, // something from op_context,
        .is_input = false,
        .entry_index = idx
      );
}

operation transfer (inputs: list&lt;xfer_input&gt;, outputs: list&lt;xfer_output&gt;) {
   val sum_inputs = map&lt;asset, integer&gt;();
   var idx = 0;
   for (i in inputs) {
      consume_input(i, idx, sum_inputs);
      idx += 1;
   }

   idx = 0;
   for (o in outputs) {
      process_transfer_output(o, idx, sum_inputs);
      idx += 1;
   }
   
}

 
//}</string>
                            </entry>
                            <entry key="main.rell">
                                <string>include 'util/index';
include 'user/index';
include 'topic/index';
include 'notifications/index';
include 'channel/index';
include 'follow/index';
include 'election/index';
include 'representative/index';

// INCLUDE OF FT# LIBRARY
include 'lib/ft3/ft3_basic';
</string>
                            </entry>
                            <entry key="notifications/index.rell">
                                <string>class notification {
    key id: text, user;
    trigger: text;
    content: text;
    mutable read: boolean;
    index timestamp;
}

include 'operations';
include 'queries';</string>
                            </entry>
                            <entry key="notifications/operations.rell">
                                <string>
operation create_notifications_for_users(name, id: text, trigger: text, content: text, usernames: set&lt;text&gt;) {
    val user = get_verified_user(name);

    for (username in usernames) {
        val toUser = user@?{ .name == username };
        if (toUser != null) {
            create notification(
                id = id, 
                toUser!!, 
                trigger = trigger,
                content = content,
                false, 
                op_context.last_block_time
            );
        }
    }
}

operation remove_notifications_for_users(name, id: text, usernames: set&lt;text&gt;) {
    val user = get_verified_user(name);

    for (username in usernames) {
        val toUser = user@?{ .name == username };
        if (toUser != null) {
            delete notification@{ id, toUser!! };
        }
    }
}

operation mark_notifications_since_timestamp_read(name, timestamp) {
    val user = get_verified_user(name);
    update notification@*{ .user == user, .timestamp &gt; timestamp } ( read = true );
}</string>
                            </entry>
                            <entry key="notifications/queries.rell">
                                <string>query count_unread_user_notifications(name) {
    val user = user@{ .name == name };
    return notification@*{ .user == user, .read == false } ( .id );
}

query get_user_notifications_prior_to_timestamp(name, timestamp, page_size: integer) {
    val user = user@{ .name == name };
    return notification@*{ .user == user, .timestamp &lt; timestamp } (
        .id,
        .trigger,
        .content,
        .read,
        -sort .timestamp
    ) limit page_size;
}
</string>
                            </entry>
                            <entry key="representative/index.rell">
                                <string>class representative {
    key user, representative_election;
}

class representative_action {
    key id: byte_array;
    index representative;
    index timestamp;
    action: text;
}

include 'operations';
include 'queries';
include '/representative/report/index';</string>
                            </entry>
                            <entry key="representative/operations.rell">
                                <string>operation remove_topic(username: text, topic_id: text) {
    val user = get_verified_user(username);

    val recentElection = representative_election@{ .completed == true } ( .id, sort .timestamp );
    val representative = representative @{ user, .representative_election.id == recentElection.id };

    val topic = topic @{ .id == topic_id };
    update topic ( title = "[Removed]", message = "Removed by @" + user.name, removed = true );
    
    create representative_action(
        id = op_context.transaction.tx_rid, 
        representative,
        op_context.last_block_time,
        action = "Topic /t/" + topic.id + " was removed by @" + user.name
    );
}

operation remove_topic_reply(username: text, topic_reply_id: text) {
    val user = get_verified_user(username);

    val recentElection = representative_election@{ .completed == true } ( .id, sort .timestamp );
    val representative = representative @{ user, .representative_election.id == recentElection.id };

    val reply = topic_reply @{ .id == topic_reply_id };
    update reply ( message = "Removed by @" + user.name, removed = true );

    create representative_action(
        id = op_context.transaction.tx_rid, 
        representative,
        op_context.last_block_time,
        action = "Reply in topic /t/" + reply.topic.id + " was removed by @" + user.name
    );
}

operation suspend_user(username: text, user_to_be_suspended: text) {
    val user = get_verified_user(username);

    val recentElection = representative_election@{ .completed == true } ( .id, sort .timestamp );
    val representative = representative @{ user, .representative_election.id == recentElection.id };

    val suspendee = user@{ .name == user_to_be_suspended };
    val suspendee_meta = user_meta@{ suspendee };

    require(suspendee_meta.suspended_until &lt; op_context.last_block_time);

    val updatedTimesSuspended = suspendee_meta.times_suspended + 1;
    val oneDayMillis = 86400000;
    val daysSuspended = updatedTimesSuspended * updatedTimesSuspended;
    val suspensionTimeMillis = daysSuspended * oneDayMillis;

    update suspendee_meta ( 
        suspended_until = op_context.last_block_time + suspensionTimeMillis, 
        times_suspended = updatedTimesSuspended
    );

    var daysString = " days ";
    if (daysSuspended == 1) {
        daysString = " day ";
    }

    create representative_action(
        id = op_context.transaction.tx_rid, 
        representative,
        op_context.last_block_time,
        action = "@" + suspendee.display_name + " was suspended for " + daysSuspended + daysString +  "by @" + user.display_name
    );
}

operation tmp_add_representative(admin_name: name, name) {
    require(is_signer(admin@{ .user.name == admin_name }( .user.pubkey )));
    val currentElection = representative_election @ { .timestamp &lt;= op_context.last_block_time, .completed == true } (
        .id,
        -sort .timestamp
    ) limit 1;

    create representative(user@{ .name == name }, representative_election@{ .id == currentElection.id });
}

operation tmp_remove_representative(admin_name: name, name) {
    require(is_signer(admin@{ .user.name == admin_name }( .user.pubkey )));
    val currentElection = representative_election @ { .timestamp &lt;= op_context.last_block_time, .completed == true } (
        .id,
        -sort .timestamp
    ) limit 1;

    delete representative @?{ user@{ .name == name }, representative_election@{ .id == currentElection.id }};
}</string>
                            </entry>
                            <entry key="representative/queries.rell">
                                <string>query get_representatives() {
    val election = representative_election@{ .completed == true } ( .id, -sort .timestamp );

    return representative@*{
        .representative_election.id == election.id
    } ( .user.name );
}

query get_all_representative_actions(timestamp, page_size: integer) {
    return representative_action@*{
        .timestamp &lt; timestamp
    } ( 
        .id, 
        representative = .representative.user.name, 
        -sort .timestamp, 
        .action 
    ) limit page_size;
}</string>
                            </entry>
                            <entry key="representative/report/index.rell">
                                <string>class representative_report {
    key id: text;
    index user;
    index timestamp;
    mutable handled: boolean;
    index handled;
    text;
}

include 'operations';
include 'queries';</string>
                            </entry>
                            <entry key="representative/report/operations.rell">
                                <string>operation create_representative_report(username: text, id: text, text) {
    val user = user@{ .name == username };
    require(is_signer(user.pubkey));
    require(user_meta@{ user }.suspended_until &lt; op_context.last_block_time);

    create representative_report(id= id, user, op_context.last_block_time, false, text = text);
}

operation handle_representative_report(username: text, id: text) {
    val user = user@{ .name == username };
    require(is_signer(user.pubkey));

    val recentElection = representative_election@{ .completed == true } ( .id, sort .timestamp );
    val representative = representative @{ user, .representative_election.id == recentElection.id };

    val report = representative_report@{ .id == id };
    update report ( handled = true );

    create representative_action(
        id = op_context.transaction.tx_rid, 
        representative,
        op_context.last_block_time,
        action = "Report: '" + report.text + "' was handled by @" + user.name
    );
}</string>
                            </entry>
                            <entry key="representative/report/queries.rell">
                                <string>query get_unhandled_representative_reports() {
    return representative_report@*{ .handled == false } ( .id, user = .user.name, -sort .timestamp, .handled, .text );
}</string>
                            </entry>
                            <entry key="topic/functions.rell">
                                <string>function find_topic_by_id(id: text): topic {
    return topic@{ .id == id };
}</string>
                            </entry>
                            <entry key="topic/index.rell">
                                <string>class topic {
    key id: text;
    index author: user;
    index timestamp;
    mutable last_modified: timestamp;
    index last_modified;
    mutable title: name;
    mutable message: text;
    mutable removed: boolean;
}

class topic_reply {
    key id: text;
    index topic;
    index author: user;
    index timestamp;
    index is_sub_reply : boolean;
    mutable message: text;
    mutable removed: boolean;
}

class sub_reply {
    key parent_reply: topic_reply, child_reply: topic_reply;
}

include 'functions';
include 'operations';
include 'queries';
include '/topic/rating/index';
include '/topic/subscription/index';</string>
                            </entry>
                            <entry key="topic/operations.rell">
                                <string>operation create_topic(id: text, username: text, channel_key: name, channel_name: name, title: name, message: text) {
    log("Username: ", username);
    val author = get_verified_user(username);

    val topic = create topic(
        id = id, 
        author,
        timestamp = op_context.last_block_time,
        last_modified = op_context.last_block_time,
        title = title,
        message = message,
        removed = false
    );

    // TODO: .lower_case() on name (key)
    create channel(name = channel_key, topic, op_context.last_block_time, display_name = channel_name);
    create tmp_topic_rating (topic, 0);
}

operation modify_topic(id: text, username: text, text) {
    val author = get_verified_user(username);

    val topic = topic@{ .id == id, .author == author };
    val fiveMinutesInMillis = 300000;
    require(op_context.last_block_time &lt; topic.timestamp + fiveMinutesInMillis);
    update topic ( message = text );
}

operation create_reply(topic_id: text, id: text, username: text, message: text) {
    val author = get_verified_user(username);
    val topic = find_topic_by_id(topic_id);

    create topic_reply(
        id = id,
        topic,
        author,
        timestamp = op_context.last_block_time,
        is_sub_reply = false,
        message = message,
        removed = false
    );

    if (not topic.removed) {
        update topic ( last_modified = op_context.last_block_time);
    }
}

operation modify_reply(id: text, username: text, text) {
    val author = get_verified_user(username);

    val reply = topic_reply@{ .id == id, .author == author };
    val fiveMinutesInMillis = 300000;
    require(op_context.last_block_time &lt; reply.timestamp + fiveMinutesInMillis);
    update reply ( message = text );
}

operation create_sub_reply(topic_id: text, parent_reply_id: text, id: text, username: text, message: text) {
    val author = get_verified_user(username);
    val topic = find_topic_by_id(topic_id);

    val topic_reply = create topic_reply(
        id = id,
        topic,
        author,
        timestamp = op_context.last_block_time,
        is_sub_reply = true,
        message = message,
        removed = false
    );

    create sub_reply(
        parent_reply = topic_reply@{ .id == parent_reply_id },
        child_reply = topic_reply
    );

    if (not topic.removed) {
        update topic ( last_modified = op_context.last_block_time);
    }
}</string>
                            </entry>
                            <entry key="topic/queries.rell">
                                <string>query get_topics_after_timestamp(timestamp, page_size: integer) {
    return topic @* { 
        .last_modified &gt; timestamp
    }(
        .id,
        author=.author.display_name,
        .title,
        .message,
        -sort .last_modified,
        .removed,
        .timestamp
    ) limit page_size;
}

query get_topics_prior_to_timestamp(timestamp, page_size: integer) {
    return topic @* { 
        .last_modified &lt; timestamp
    }(
        .id,
        author=.author.display_name,
        .title,
        .message,
        -sort .last_modified,
        .removed,
        .timestamp
    ) limit page_size;
}

query get_topic_replies_prior_to_timestamp(topic_id: text, timestamp, page_size: integer) {
    return topic_reply@*{
        topic@{ .id == topic_id },
        .timestamp &lt; timestamp,
        .is_sub_reply == false
    }(
        .id,
        topic_id = .topic.id,
        author=.author.display_name,
        .message,
        .is_sub_reply,
        .removed,
        -sort .timestamp
    ) limit page_size;
}

query get_topic_replies_after_timestamp(topic_id: text, timestamp, page_size: integer) {
    return topic_reply@*{
        topic@{ .id == topic_id },
        .timestamp &gt; timestamp,
        .is_sub_reply == false
    }(
        .id,
        topic_id = .topic.id,
        author=.author.display_name,
        .message,
        .is_sub_reply,
        .removed,
        -sort .timestamp
    ) limit page_size;
}

query get_topic_replies_by_user_prior_to_timestamp(name, timestamp, page_size: integer) {
    return topic_reply@*{ .author.name == name, .timestamp &lt; timestamp } (
        .id,
        topic_id = .topic.id,
        author=.author.display_name,
        .message,
        .is_sub_reply,
        .removed,
        -sort .timestamp
    ) limit page_size;
}

query count_topics_by_user(name): integer {
    return topic@*{ .author.name == name }( .id ).size();
}

query count_replies_by_user(name): integer {
    return topic_reply@*{ .author.name == name }( .id ).size();
}

query get_sub_replies(parent_reply_id: text) {
    return sub_reply@*{ .parent_reply.id == parent_reply_id } (
        id=.child_reply.id,
        author=.child_reply.author.display_name,
        message=.child_reply.message,
        is_sub_reply=.child_reply.is_sub_reply,
        removed = .child_reply.removed,
        sort timestamp=.child_reply.timestamp
    );
}

query get_topics_by_user_id_prior_to_timestamp(name, timestamp, page_size: integer) {
    return topic@*{
        user@{ .name == name },
        .last_modified &lt; timestamp
    }(
        .id,
        author=.author.display_name,
        .title,
        .message,
        -sort .last_modified,
        .removed,
        .timestamp
    ) limit page_size;
}

query get_topics_from_follows_after_timestamp(name, timestamp, page_size: integer) {
    return topic@*{
        follow@{ .follower.name == name } ( .follows ),
        .last_modified &gt; timestamp
    }(
        .id,
        author=.author.display_name,
        .title,
        .message,
        -sort .last_modified,
        .removed,
        .timestamp
    ) limit page_size;
}

query get_topics_from_follows_prior_to_timestamp(name, timestamp, page_size: integer) {
    return topic@*{
        follow@{ .follower.name == name } ( .follows ),
        .last_modified &lt; timestamp
    }(
        .id,
        author=.author.display_name,
        .title,
        .message,
        .removed,
        -sort .last_modified,
        .timestamp
    ) limit page_size;
}

query get_topic_by_id(id: text) {
    return topic@{
        .id == id
    }(
        .id,
        author=.author.display_name,
        .title,
        .message,
        .removed,
        -sort .last_modified,
        .timestamp
    );
}

query get_all_topics_by_stars_since_timestamp(timestamp, page_size: integer) {
    return tmp_topic_rating@*{ .topic.timestamp &gt; timestamp } (
        -sort .stars,
        id = .topic.id,
        author=.topic.author.display_name,
        title=.topic.title,
        message=.topic.message,
        last_modified=.topic.last_modified,
        timestamp=.topic.timestamp
    ) limit page_size;
}

query get_topics_by_follows_and_stars_since_timestamp(name, timestamp, page_size: integer) {
    return tmp_topic_rating@*{ 
            .topic.author == follow@{ .follower.name == name } ( .follows ),
            .topic.timestamp &gt; timestamp
        } (
        -sort .stars,
        id = .topic.id,
        author=.topic.author.display_name,
        title=.topic.title,
        message=.topic.message,
        last_modified=.topic.last_modified,
        timestamp=.topic.timestamp
    ) limit page_size;
}

query get_topics_by_channel_after_timestamp_sorted_by_popularity(name, timestamp, page_size: integer) {
    return (tmp_topic_rating, channel)@*{
        name == channel.name,
        tmp_topic_rating.topic == channel.topic,
        tmp_topic_rating.topic.timestamp &gt; timestamp
    } (
        -sort .stars,
        id = channel.topic.id,
        author=channel.topic.author.display_name,
        title=channel.topic.title,
        message=channel.topic.message,
        last_modified=channel.topic.last_modified,
        timestamp=channel.topic.timestamp
    ) limit page_size;
}

query get_topics_by_followed_channels_after_timestamp_sorted_by_popularity(name, timestamp, page_size: integer) {
    return (tmp_topic_rating, channel_following, channel)@*{
        channel_following.user == user@{ name },
        channel_following.name == channel.name,
        tmp_topic_rating.topic == channel.topic,
        tmp_topic_rating.topic.timestamp &gt; timestamp
    } (
        -sort .stars,
        id = channel.topic.id,
        author=channel.topic.author.display_name,
        title=channel.topic.title,
        message=channel.topic.message,
        last_modified=channel.topic.last_modified,
        timestamp=channel.topic.timestamp
    ) limit page_size;
}</string>
                            </entry>
                            <entry key="topic/rating/index.rell">
                                <string>class topic_star_rating {
    key topic, user;
}

// To be deleted when GROUP BY and COUNT is supported, then will use topic_star_rating instead
class tmp_topic_rating {
    key topic;
    mutable stars: integer;
    index stars;
}

class reply_star_rating {
    key topic_reply, user;
}

include 'operations';
include 'queries';</string>
                            </entry>
                            <entry key="topic/rating/operations.rell">
                                <string>operation give_topic_star_rating(username: text, id: text) {
    val user = get_verified_user(username);
    create topic_star_rating(topic@{ .id == id }, user);

    val topicRating = tmp_topic_rating@{ topic@{ .id == id }};
    update topicRating ( stars = topicRating.stars + 1 );
}

operation remove_topic_star_rating(username: text, id: text) {
    val user = get_verified_user(username);
    delete topic_star_rating@{ topic@{ .id == id }, user };

    val topicRating = tmp_topic_rating@{ topic@{ .id == id }};
    update topicRating ( stars = topicRating.stars - 1 );
}

operation give_reply_star_rating(username: text, id: text) {
    val user = get_verified_user(username);
    create reply_star_rating(topic_reply@{ .id == id }, user);
}

operation remove_reply_star_rating(username: text, id: text) {
    val user = get_verified_user(username);
    delete reply_star_rating@{ topic_reply@{ .id == id }, user };
}</string>
                            </entry>
                            <entry key="topic/rating/queries.rell">
                                <string>query get_star_rating_for_topic(id: text) {
    return topic_star_rating@*{ topic@{ .id == id }} ( .user.name );
}

query get_star_rating_for_reply(id: text) {
    return reply_star_rating@*{ topic_reply@{ .id == id }} ( .user.name );
}

query count_user_topic_star_rating(name): integer {
    return topic_star_rating@*{ .topic.author.name == name } ( .topic, .user ).size();
}

query count_user_reply_star_rating(name): integer {
    return reply_star_rating@*{ .topic_reply.author.name == name } ( .topic_reply, .user ).size();
}</string>
                            </entry>
                            <entry key="topic/subscription/index.rell">
                                <string>class subscription {
    key topic, user;
}

include 'operations';
include 'queries';</string>
                            </entry>
                            <entry key="topic/subscription/operations.rell">
                                <string>operation subscribe_to_topic(username: text, id: text) {
    val user = get_verified_user(username);
    create subscription(topic@{ .id == id }, user);
}

operation unsubscribe_from_topic(username: text, id: text) {
    val user = get_verified_user(username);
    delete subscription@{ topic@{ .id == id }, user };
}</string>
                            </entry>
                            <entry key="topic/subscription/queries.rell">
                                <string>query get_subscribers_for_topic(id: text) {
    return subscription@*{ topic@{ .id == id }} ( .user.name );
}</string>
                            </entry>
                            <entry key="user/functions.rell">
                                <string>function get_verified_user(name): user {
    val user = user@{ .name == name };

    require(is_signer(user.pubkey));
    require(user_meta@{ user }.suspended_until &lt; op_context.last_block_time);

    return user;
}</string>
                            </entry>
                            <entry key="user/index.rell">
                                <string>class admin {
    user;
}

class user {
    key name;
    display_name: name;
    pubkey;
    registered: integer;
}

include 'functions';
include 'operations';
include 'queries';
include '/user/settings/index';
include '/user/meta/index';
include '/user/mute/index';</string>
                            </entry>
                            <entry key="user/meta/index.rell">
                                <string>class user_meta {
    key user;
    mutable times_suspended: integer;
    mutable suspended_until: timestamp;
}

include 'operations';
include 'queries';</string>
                            </entry>
                            <entry key="user/meta/operations.rell">
                                <string></string>
                            </entry>
                            <entry key="user/meta/queries.rell">
                                <string>query get_user_meta(name) {
    return user_meta@{ user@{ name }} ( 
        name = .user.name, 
        times_suspended = .times_suspended, 
        suspended_until = .suspended_until 
    );
}</string>
                            </entry>
                            <entry key="user/mute/index.rell">
                                <string>class user_mute {
    key user, muted_user: user;
}

include 'operations';
include 'queries';</string>
                            </entry>
                            <entry key="user/mute/operations.rell">
                                <string>operation toggle_mute(username: name, name, muted: boolean) {
    val user = get_verified_user(username);

    if (muted) {
        create user_mute(user = user, muted_user = user@{ .name == name });
    } else {
        delete user_mute@{ .user == user, .muted_user == user@{ .name == name }};
    }
}</string>
                            </entry>
                            <entry key="user/mute/queries.rell">
                                <string>query get_muted_users(username: name) {
    return user_mute@*{ .user.name == username } ( .muted_user.name );
}</string>
                            </entry>
                            <entry key="user/operations.rell">
                                <string>operation register_user(name, display_name: text, pubkey) {
    require(is_signer(pubkey));

    log("Name: ", name, " - Display Name: ", display_name);

    if (name == "admin") {
        val admin = create user(name, display_name, pubkey, op_context.transaction.block.block_height);
        create admin(admin);
        create user_settings(admin, avatar = "" , description = "");
        create user_meta(admin, times_suspended = 0, suspended_until = 0);
    } else {
        val user = create user(name, display_name, pubkey, op_context.transaction.block.block_height);
        create user_settings(user, avatar = "" , description = "");
        create user_meta(user, times_suspended = 0, suspended_until = 0);
    }
}
</string>
                            </entry>
                            <entry key="user/queries.rell">
                                <string>
query get_user(name) {
    return user@?{ .name == name } ( name = .display_name, .pubkey, .registered );
}
</string>
                            </entry>
                            <entry key="user/settings/index.rell">
                                <string>class user_settings {
    key user;
    mutable avatar: text;
    mutable description: text;
}

include 'operations';
include 'queries';</string>
                            </entry>
                            <entry key="user/settings/operations.rell">
                                <string>operation create_user_settings(name, avatar: text, description: text) {
    val user = get_verified_user(name);
    create user_settings(user, avatar = avatar, description = description);
}

operation update_user_settings(name, avatar: text, description: text) {
    val user = get_verified_user(name);
    update user_settings@{ .user == user }( avatar = avatar, description = description );
}</string>
                            </entry>
                            <entry key="user/settings/queries.rell">
                                <string>query get_user_settings(name) {
    return user_settings@?{ user@{ .name == name }} ( .avatar, .description );
}</string>
                            </entry>
                            <entry key="util/index.rell">
                                <string>include 'text-util';</string>
                            </entry>
                            <entry key="util/text-util.rell">
                                <string></string>
                            </entry>
                        </dict>
                    </entry>
                </dict>
            </entry>
        </dict>
    </entry>
    <entry key="signers">
        <array>
            <bytea>0350FE40766BC0CE8D08B3F5B810E49A8352FDD458606BD5FAFE5ACDCDC8FF3F57</bytea>
        </array>
    </entry>
</dict>
